<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavadocMethodCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.javadoc</a> &gt; <span class="el_source">JavadocMethodCheck.java</span></div><h1>JavadocMethodCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.javadoc;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FileContents;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.Scope;
import com.puppycrawl.tools.checkstyle.api.TextBlock;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.AnnotationUtil;
import com.puppycrawl.tools.checkstyle.utils.CheckUtil;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;

/**
 * &lt;p&gt;
 * Checks the Javadoc of a method or constructor. By default,
 * check does not validate methods and constructors for unused throws.
 * To allow documented exceptions derived from {@code java.lang.RuntimeException}
 * that are not declared, set property {@code allowUndeclaredRTE} to true.
 * The scope to verify is specified using the {@code Scope} class and defaults
 * to {@code Scope.PRIVATE}. To verify another scope, set property scope to
 * a different &lt;a href=&quot;https://checkstyle.org/property_types.html#scope&quot;&gt;scope&lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Violates parameters and type parameters for which no param tags are present
 * can be suppressed by defining property {@code allowMissingParamTags}.
 * Violates exceptions which are declared to be thrown, but for which no throws
 * tag is present can be suppressed by defining property {@code allowMissingThrowsTags}.
 * Violates methods which return non-void but for which no return tag is present
 * can be suppressed by defining property {@code allowMissingReturnTag}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Javadoc is not required on a method that is tagged with the {@code @Override}
 * annotation. However under Java 5 it is not possible to mark a method required
 * for an interface (this was &lt;i&gt;corrected&lt;/i&gt; under Java 6). Hence Checkstyle
 * supports using the convention of using a single {@code {@inheritDoc}} tag
 * instead of all the other tags.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note that only inheritable items will allow the {@code {@inheritDoc}}
 * tag to be used in place of comments. Static methods at all visibilities,
 * private non-static methods and constructors are not inheritable.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if the following method is implementing a method required by
 * an interface, then the Javadoc could be done as:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;#47;** {&amp;#64;inheritDoc} *&amp;#47;
 * public int checkReturnTag(final int aTagIndex,
 *                           JavadocTag[] aTags,
 *                           int aLineNo)
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The classpath may need to be configured to locate the class information.
 * The classpath configuration is dependent on the mechanism used to invoke Checkstyle.
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * Property {@code allowedAnnotations} - Specify the list of annotations
 * that allow missed documentation.
 * Default value is {@code Override}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code validateThrows} - Control whether to validate {@code throws} tags.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code scope} - Specify the visibility scope where Javadoc comments are checked.
 * Default value is {@code private}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code excludeScope} - Specify the visibility scope where Javadoc comments
 * are not checked.
 * Default value is {@code null}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowUndeclaredRTE} - Control whether to allow documented exceptions
 * that are not declared if they are a subclass of {@code java.lang.RuntimeException}.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowThrowsTagsForSubclasses} - Control whether to allow
 * documented exceptions that are subclass of one of declared exception.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowMissingParamTags} - Control whether to ignore violations
 * when a method has parameters but does not have matching {@code param} tags in the javadoc.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowMissingThrowsTags} - Control whether to ignore violations
 * when a method declares that it throws exceptions but does not have matching
 * {@code throws} tags in the javadoc.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code allowMissingReturnTag} - Control whether to ignore violations
 * when a method returns non-void type and does not have a {@code return} tag in the javadoc.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code logLoadErrors} - Control checkstyle's error handling when
 * a class loading fails. This check may need to load exception classes mentioned
 * in the {@code @throws} tag to check whether they are RuntimeExceptions.
 * If set to {@code false} a classpath configuration problem is assumed and
 * the TreeWalker stops operating on the class completely. If set to {@code true}
 * (the default), checkstyle assumes a typo or refactoring problem in the javadoc
 * and logs the problem in the normal checkstyle report (potentially masking
 * a configuration error).
 * Default value is {@code true}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code suppressLoadErrors} - Control whether to suppress violations
 * when a class loading fails. When logLoadErrors is set to true, the TreeWalker
 * completely processes a class and displays any problems with loading exceptions
 * as checkstyle violations. When this property is set to true, the violations
 * generated when logLoadErrors is set true are suppressed from being reported as
 * violations in the checkstyle report.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code tokens} - tokens to check Default value is:
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#METHOD_DEF&quot;&gt;
 * METHOD_DEF&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CTOR_DEF&quot;&gt;
 * CTOR_DEF&lt;/a&gt;,
 * &lt;a href=&quot;https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ANNOTATION_FIELD_DEF&quot;&gt;
 * ANNOTATION_FIELD_DEF&lt;/a&gt;.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * To configure the default check:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;JavadocMethod&quot;/&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check for {@code public} scope and to allow documentation
 * of undeclared RuntimeExceptions:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;JavadocMethod&quot;&amp;gt;
 *   &amp;lt;property name=&quot;scope&quot; value=&quot;public&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;allowUndeclaredRTE&quot; value=&quot;true&quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check for for {@code public} scope, to allow documentation
 * of undeclared RuntimeExceptions, while ignoring any missing param tags is:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;JavadocMethod&quot;&amp;gt;
 *   &amp;lt;property name=&quot;scope&quot; value=&quot;public&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;allowUndeclaredRTE&quot; value=&quot;true&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;allowMissingParamTags&quot; value=&quot;true&quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check for methods which are in {@code private},
 * but not in {@code protected} scope:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;JavadocMethod&quot;&amp;gt;
 *   &amp;lt;property name=&quot;scope&quot; value=&quot;private&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;excludeScope&quot; value=&quot;protected&quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 *
 * @since 3.0
 */
@FileStatefulCheck
<span class="fc" id="L210">public class JavadocMethodCheck extends AbstractCheck {</span>

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_CLASS_INFO = &quot;javadoc.classInfo&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_UNUSED_TAG_GENERAL = &quot;javadoc.unusedTagGeneral&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_INVALID_INHERIT_DOC = &quot;javadoc.invalidInheritDoc&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_UNUSED_TAG = &quot;javadoc.unusedTag&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_EXPECTED_TAG = &quot;javadoc.expectedTag&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_RETURN_EXPECTED = &quot;javadoc.return.expected&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_DUPLICATE_TAG = &quot;javadoc.duplicateTag&quot;;

    /** Compiled regexp to match Javadoc tags that take an argument. */
<span class="fc" id="L255">    private static final Pattern MATCH_JAVADOC_ARG = CommonUtil.createPattern(</span>
            &quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(throws|exception|param)\\s+(\\S+)\\s+\\S*&quot;);
    /** Compiled regexp to match Javadoc tags with argument but with missing description. */
<span class="fc" id="L258">    private static final Pattern MATCH_JAVADOC_ARG_MISSING_DESCRIPTION =</span>
<span class="fc" id="L259">        CommonUtil.createPattern(&quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(throws|exception|param)\\s+&quot;</span>
            + &quot;(\\S[^*]*)(?:(\\s+|\\*\\/))?&quot;);

    /** Compiled regexp to look for a continuation of the comment. */
<span class="fc" id="L263">    private static final Pattern MATCH_JAVADOC_MULTILINE_CONT =</span>
<span class="fc" id="L264">            CommonUtil.createPattern(&quot;(\\*\\/|@|[^\\s\\*])&quot;);</span>

    /** Multiline finished at end of comment. */
    private static final String END_JAVADOC = &quot;*/&quot;;
    /** Multiline finished at next Javadoc. */
    private static final String NEXT_TAG = &quot;@&quot;;

    /** Compiled regexp to match Javadoc tags with no argument. */
<span class="fc" id="L272">    private static final Pattern MATCH_JAVADOC_NOARG =</span>
<span class="fc" id="L273">            CommonUtil.createPattern(&quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(return|see)\\s+\\S&quot;);</span>
    /** Compiled regexp to match first part of multilineJavadoc tags. */
<span class="fc" id="L275">    private static final Pattern MATCH_JAVADOC_NOARG_MULTILINE_START =</span>
<span class="fc" id="L276">            CommonUtil.createPattern(&quot;^\\s*(?&gt;\\*|\\/\\*\\*)?\\s*@(return|see)\\s*$&quot;);</span>
    /** Compiled regexp to match Javadoc tags with no argument and {}. */
<span class="fc" id="L278">    private static final Pattern MATCH_JAVADOC_NOARG_CURLY =</span>
<span class="fc" id="L279">            CommonUtil.createPattern(&quot;\\{\\s*@(inheritDoc)\\s*\\}&quot;);</span>

    /** Stack of maps for type params. */
<span class="fc" id="L282">    private final Deque&lt;Map&lt;String, AbstractClassInfo&gt;&gt; currentTypeParams = new ArrayDeque&lt;&gt;();</span>

    /** Imports details. **/
<span class="fc" id="L285">    private final Set&lt;String&gt; imports = new HashSet&lt;&gt;();</span>

    /** Full identifier for package of the method. **/
    private FullIdent packageFullIdent;

    /** Name of current class. */
    private String currentClassName;

    /** {@code ClassResolver} instance for current tree. */
    private ClassResolver classResolver;

    /** Specify the visibility scope where Javadoc comments are checked. */
<span class="fc" id="L297">    private Scope scope = Scope.PRIVATE;</span>

    /** Specify the visibility scope where Javadoc comments are not checked. */
    private Scope excludeScope;

    /**
     * Control whether to allow documented exceptions that are not declared if
     * they are a subclass of {@code java.lang.RuntimeException}.
     */
    // -@cs[AbbreviationAsWordInName] We can not change it as,
    // check's property is part of API (used in configurations).
    private boolean allowUndeclaredRTE;

    /**
     * Control whether to validate {@code throws} tags.
     */
    private boolean validateThrows;

    /**
     * Control whether to allow documented exceptions that are subclass of one
     * of declared exception.
     */
    private boolean allowThrowsTagsForSubclasses;

    /**
     * Control whether to ignore violations when a method has parameters but does
     * not have matching {@code param} tags in the javadoc.
     */
    private boolean allowMissingParamTags;

    /**
     * Control whether to ignore violations when a method declares that it throws
     * exceptions but does not have matching {@code throws} tags in the javadoc.
     */
    private boolean allowMissingThrowsTags;

    /**
     * Control whether to ignore violations when a method returns non-void type
     * and does not have a {@code return} tag in the javadoc.
     */
    private boolean allowMissingReturnTag;

    /** Specify the list of annotations that allow missed documentation. */
<span class="fc" id="L340">    private List&lt;String&gt; allowedAnnotations = Collections.singletonList(&quot;Override&quot;);</span>

    /**
     * Setter to control whether to validate {@code throws} tags.
     *
     * @param value user's value.
     */
    public void setValidateThrows(boolean value) {
<span class="fc" id="L348">        validateThrows = value;</span>
<span class="fc" id="L349">    }</span>

    /**
     * Setter to specify the list of annotations that allow missed documentation.
     *
     * @param userAnnotations user's value.
     */
    public void setAllowedAnnotations(String... userAnnotations) {
<span class="fc" id="L357">        allowedAnnotations = Arrays.asList(userAnnotations);</span>
<span class="fc" id="L358">    }</span>

    /**
     * Setter to specify the visibility scope where Javadoc comments are checked.
     *
     * @param scope a scope.
     */
    public void setScope(Scope scope) {
<span class="fc" id="L366">        this.scope = scope;</span>
<span class="fc" id="L367">    }</span>

    /**
     * Setter to specify the visibility scope where Javadoc comments are not checked.
     *
     * @param excludeScope a scope.
     */
    public void setExcludeScope(Scope excludeScope) {
<span class="fc" id="L375">        this.excludeScope = excludeScope;</span>
<span class="fc" id="L376">    }</span>

    /**
     * Setter to control whether to allow documented exceptions that are not declared if
     * they are a subclass of {@code java.lang.RuntimeException}.
     *
     * @param flag a {@code Boolean} value
     */
    // -@cs[AbbreviationAsWordInName] We can not change it as,
    // check's property is part of API (used in configurations).
    public void setAllowUndeclaredRTE(boolean flag) {
<span class="fc" id="L387">        allowUndeclaredRTE = flag;</span>
<span class="fc" id="L388">    }</span>

    /**
     * Setter to control whether to allow documented exceptions that are subclass of one
     * of declared exception.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowThrowsTagsForSubclasses(boolean flag) {
<span class="fc" id="L397">        allowThrowsTagsForSubclasses = flag;</span>
<span class="fc" id="L398">    }</span>

    /**
     * Setter to control whether to ignore violations when a method has parameters
     * but does not have matching {@code param} tags in the javadoc.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingParamTags(boolean flag) {
<span class="fc" id="L407">        allowMissingParamTags = flag;</span>
<span class="fc" id="L408">    }</span>

    /**
     * Setter to control whether to ignore violations when a method declares that it throws
     * exceptions but does not have matching {@code throws} tags in the javadoc.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingThrowsTags(boolean flag) {
<span class="fc" id="L417">        allowMissingThrowsTags = flag;</span>
<span class="fc" id="L418">    }</span>

    /**
     * Setter to control whether to ignore violations when a method returns non-void type
     * and does not have a {@code return} tag in the javadoc.
     *
     * @param flag a {@code Boolean} value
     */
    public void setAllowMissingReturnTag(boolean flag) {
<span class="fc" id="L427">        allowMissingReturnTag = flag;</span>
<span class="fc" id="L428">    }</span>

    /**
     * Setter to control checkstyle's error handling when a class loading fails.
     * This check may need to load exception classes mentioned in the {@code @throws}
     * tag to check whether they are RuntimeExceptions. If set to {@code false}
     * a classpath configuration problem is assumed and the TreeWalker stops operating
     * on the class completely. If set to {@code true}(the default), checkstyle assumes
     * a typo or refactoring problem in the javadoc and logs the problem in the normal
     * checkstyle report (potentially masking a configuration error).
     *
     * @param logLoadErrors true if errors should be logged
     * @deprecated No substitute.
     */
    @Deprecated
    public final void setLogLoadErrors(boolean logLoadErrors) {
        // no code
<span class="fc" id="L445">    }</span>

    /**
     * Setter to control whether to suppress violations when a class loading fails.
     * When logLoadErrors is set to true, the TreeWalker completely processes
     * a class and displays any problems with loading exceptions as checkstyle violations.
     * When this property is set to true, the violations generated when logLoadErrors
     * is set true are suppressed from being reported as violations in the checkstyle report.
     *
     * @param suppressLoadErrors true if errors shouldn't be shown
     * @deprecated No substitute.
     */
    @Deprecated
    public final void setSuppressLoadErrors(boolean suppressLoadErrors) {
        // no code
<span class="fc" id="L460">    }</span>

    @Override
    public final int[] getRequiredTokens() {
<span class="fc" id="L464">        return new int[] {</span>
            TokenTypes.PACKAGE_DEF,
            TokenTypes.IMPORT,
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
        };
    }

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L475">        return getAcceptableTokens();</span>
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L480">        return new int[] {</span>
            TokenTypes.PACKAGE_DEF,
            TokenTypes.IMPORT,
            TokenTypes.CLASS_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
            TokenTypes.ANNOTATION_FIELD_DEF,
        };
    }

    @Override
    public void beginTree(DetailAST rootAST) {
<span class="fc" id="L494">        packageFullIdent = FullIdent.createFullIdent(null);</span>
<span class="fc" id="L495">        imports.clear();</span>
        // add java.lang.* since it's always imported
<span class="fc" id="L497">        imports.add(&quot;java.lang.*&quot;);</span>
<span class="fc" id="L498">        classResolver = null;</span>
<span class="fc" id="L499">        currentClassName = &quot;&quot;;</span>
<span class="fc" id="L500">        currentTypeParams.clear();</span>
<span class="fc" id="L501">    }</span>

    @Override
    public final void visitToken(DetailAST ast) {
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (ast.getType() == TokenTypes.PACKAGE_DEF) {</span>
<span class="fc" id="L506">            processPackage(ast);</span>
        }
<span class="fc bfc" id="L508" title="All 2 branches covered.">        else if (ast.getType() == TokenTypes.IMPORT) {</span>
<span class="fc" id="L509">            processImport(ast);</span>
        }
<span class="fc bfc" id="L511" title="All 2 branches covered.">        else if (ast.getType() == TokenTypes.CLASS_DEF</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                 || ast.getType() == TokenTypes.INTERFACE_DEF</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">                 || ast.getType() == TokenTypes.ENUM_DEF) {</span>
<span class="fc" id="L514">            processClass(ast);</span>
        }
        else {
<span class="fc bfc" id="L517" title="All 2 branches covered.">            if (ast.getType() == TokenTypes.METHOD_DEF) {</span>
<span class="fc" id="L518">                processTypeParams(ast);</span>
            }
<span class="fc" id="L520">            processAST(ast);</span>
        }
<span class="fc" id="L522">    }</span>

    @Override
    public final void leaveToken(DetailAST ast) {
<span class="fc bfc" id="L526" title="All 2 branches covered.">        if (ast.getType() == TokenTypes.CLASS_DEF</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            || ast.getType() == TokenTypes.INTERFACE_DEF</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">            || ast.getType() == TokenTypes.ENUM_DEF) {</span>
            // perhaps it was inner class
<span class="fc" id="L530">            int dotIdx = currentClassName.lastIndexOf('$');</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (dotIdx == -1) {</span>
                // perhaps just a class
<span class="fc" id="L533">                dotIdx = currentClassName.lastIndexOf('.');</span>
            }
<span class="fc bfc" id="L535" title="All 2 branches covered.">            if (dotIdx == -1) {</span>
                // looks like a topmost class
<span class="fc" id="L537">                currentClassName = &quot;&quot;;</span>
            }
            else {
<span class="fc" id="L540">                currentClassName = currentClassName.substring(0, dotIdx);</span>
            }
<span class="fc" id="L542">            currentTypeParams.pop();</span>
<span class="fc" id="L543">        }</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">        else if (ast.getType() == TokenTypes.METHOD_DEF) {</span>
<span class="fc" id="L545">            currentTypeParams.pop();</span>
        }
<span class="fc" id="L547">    }</span>

    /**
     * Called to process an AST when visiting it.
     * @param ast the AST to process. Guaranteed to not be PACKAGE_DEF or
     *             IMPORT tokens.
     */
    private void processAST(DetailAST ast) {
<span class="fc" id="L555">        final Scope theScope = calculateScope(ast);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (shouldCheck(ast, theScope)) {</span>
<span class="fc" id="L557">            final FileContents contents = getFileContents();</span>
<span class="fc" id="L558">            final TextBlock textBlock = contents.getJavadocBefore(ast.getLineNo());</span>

<span class="fc bfc" id="L560" title="All 2 branches covered.">            if (textBlock != null) {</span>
<span class="fc" id="L561">                checkComment(ast, textBlock);</span>
            }
        }
<span class="fc" id="L564">    }</span>

    /**
     * Whether we should check this node.
     *
     * @param ast a given node.
     * @param nodeScope the scope of the node.
     * @return whether we should check a given node.
     */
    private boolean shouldCheck(final DetailAST ast, final Scope nodeScope) {
<span class="fc" id="L574">        final Scope surroundingScope = ScopeUtil.getSurroundingScope(ast);</span>

<span class="fc bfc" id="L576" title="All 6 branches covered.">        return (excludeScope == null</span>
                || nodeScope != excludeScope
                &amp;&amp; surroundingScope != excludeScope)
<span class="fc bfc" id="L579" title="All 2 branches covered.">            &amp;&amp; nodeScope.isIn(scope)</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">            &amp;&amp; surroundingScope.isIn(scope);</span>
    }

    /**
     * Checks the Javadoc for a method.
     *
     * @param ast the token for the method
     * @param comment the Javadoc comment
     */
    private void checkComment(DetailAST ast, TextBlock comment) {
<span class="fc" id="L590">        final List&lt;JavadocTag&gt; tags = getMethodTags(comment);</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (!hasShortCircuitTag(ast, tags)) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            if (ast.getType() == TokenTypes.ANNOTATION_FIELD_DEF) {</span>
<span class="fc" id="L594">                checkReturnTag(tags, ast.getLineNo(), true);</span>
            }
            else {
<span class="fc" id="L597">                final Iterator&lt;JavadocTag&gt; it = tags.iterator();</span>
                // Check for inheritDoc
<span class="fc" id="L599">                boolean hasInheritDocTag = false;</span>
<span class="fc bfc" id="L600" title="All 4 branches covered.">                while (!hasInheritDocTag &amp;&amp; it.hasNext()) {</span>
<span class="fc" id="L601">                    hasInheritDocTag = it.next().isInheritDocTag();</span>
                }
<span class="fc bfc" id="L603" title="All 2 branches covered.">                final boolean reportExpectedTags = !hasInheritDocTag</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">                    &amp;&amp; !AnnotationUtil.containsAnnotation(ast, allowedAnnotations);</span>

<span class="fc" id="L606">                checkParamTags(tags, ast, reportExpectedTags);</span>
<span class="fc" id="L607">                checkThrowsTags(tags, getThrows(ast), reportExpectedTags);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">                if (CheckUtil.isNonVoidMethod(ast)) {</span>
<span class="fc" id="L609">                    checkReturnTag(tags, ast.getLineNo(), reportExpectedTags);</span>
                }
            }

            // Dump out all unused tags
<span class="fc bfc" id="L614" title="All 2 branches covered.">            tags.stream().filter(javadocTag -&gt; !javadocTag.isSeeOrInheritDocTag())</span>
<span class="fc" id="L615">                .forEach(javadocTag -&gt; log(javadocTag.getLineNo(), MSG_UNUSED_TAG_GENERAL));</span>
        }
<span class="fc" id="L617">    }</span>

    /**
     * Validates whether the Javadoc has a short circuit tag. Currently this is
     * the inheritTag. Any violations are logged.
     *
     * @param ast the construct being checked
     * @param tags the list of Javadoc tags associated with the construct
     * @return true if the construct has a short circuit tag.
     */
    private boolean hasShortCircuitTag(final DetailAST ast, final List&lt;JavadocTag&gt; tags) {
<span class="fc" id="L628">        boolean result = true;</span>
        // Check if it contains {@inheritDoc} tag
<span class="fc bfc" id="L630" title="All 2 branches covered.">        if (tags.size() == 1</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">                &amp;&amp; tags.get(0).isInheritDocTag()) {</span>
            // Invalid if private, a constructor, or a static method
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {</span>
<span class="fc" id="L634">                log(ast, MSG_INVALID_INHERIT_DOC);</span>
            }
        }
        else {
<span class="fc" id="L638">            result = false;</span>
        }
<span class="fc" id="L640">        return result;</span>
    }

    /**
     * Returns the scope for the method/constructor at the specified AST. If
     * the method is in an interface or annotation block, the scope is assumed
     * to be public.
     *
     * @param ast the token of the method/constructor
     * @return the scope of the method/constructor
     */
    private static Scope calculateScope(final DetailAST ast) {
        final Scope scope;

<span class="fc bfc" id="L654" title="All 2 branches covered.">        if (ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {</span>
<span class="fc" id="L655">            scope = Scope.PUBLIC;</span>
        }
        else {
<span class="fc" id="L658">            final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L659">            scope = ScopeUtil.getScopeFromMods(mods);</span>
        }
<span class="fc" id="L661">        return scope;</span>
    }

    /**
     * Returns the tags in a javadoc comment. Only finds throws, exception,
     * param, return and see tags.
     *
     * @param comment the Javadoc comment
     * @return the tags found
     */
    private static List&lt;JavadocTag&gt; getMethodTags(TextBlock comment) {
<span class="fc" id="L672">        final String[] lines = comment.getText();</span>
<span class="fc" id="L673">        final List&lt;JavadocTag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L674">        int currentLine = comment.getStartLineNo() - 1;</span>
<span class="fc" id="L675">        final int startColumnNumber = comment.getStartColNo();</span>

<span class="fc bfc" id="L677" title="All 2 branches covered.">        for (int i = 0; i &lt; lines.length; i++) {</span>
<span class="fc" id="L678">            currentLine++;</span>
<span class="fc" id="L679">            final Matcher javadocArgMatcher =</span>
<span class="fc" id="L680">                MATCH_JAVADOC_ARG.matcher(lines[i]);</span>
<span class="fc" id="L681">            final Matcher javadocArgMissingDescriptionMatcher =</span>
<span class="fc" id="L682">                MATCH_JAVADOC_ARG_MISSING_DESCRIPTION.matcher(lines[i]);</span>
<span class="fc" id="L683">            final Matcher javadocNoargMatcher =</span>
<span class="fc" id="L684">                MATCH_JAVADOC_NOARG.matcher(lines[i]);</span>
<span class="fc" id="L685">            final Matcher noargCurlyMatcher =</span>
<span class="fc" id="L686">                MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);</span>
<span class="fc" id="L687">            final Matcher noargMultilineStart =</span>
<span class="fc" id="L688">                MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);</span>

<span class="fc bfc" id="L690" title="All 2 branches covered.">            if (javadocArgMatcher.find()) {</span>
<span class="fc" id="L691">                final int col = calculateTagColumn(javadocArgMatcher, i, startColumnNumber);</span>
<span class="fc" id="L692">                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),</span>
<span class="fc" id="L693">                        javadocArgMatcher.group(2)));</span>
<span class="fc" id="L694">            }</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">            else if (javadocArgMissingDescriptionMatcher.find()) {</span>
<span class="fc" id="L696">                final int col = calculateTagColumn(javadocArgMissingDescriptionMatcher, i,</span>
                    startColumnNumber);
<span class="fc" id="L698">                tags.add(new JavadocTag(currentLine, col,</span>
<span class="fc" id="L699">                    javadocArgMissingDescriptionMatcher.group(1),</span>
<span class="fc" id="L700">                    javadocArgMissingDescriptionMatcher.group(2)));</span>
<span class="fc" id="L701">            }</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">            else if (javadocNoargMatcher.find()) {</span>
<span class="fc" id="L703">                final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);</span>
<span class="fc" id="L704">                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));</span>
<span class="fc" id="L705">            }</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            else if (noargCurlyMatcher.find()) {</span>
<span class="fc" id="L707">                final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);</span>
<span class="fc" id="L708">                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));</span>
<span class="fc" id="L709">            }</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">            else if (noargMultilineStart.find()) {</span>
<span class="fc" id="L711">                tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));</span>
            }
        }
<span class="fc" id="L714">        return tags;</span>
    }

    /**
     * Calculates column number using Javadoc tag matcher.
     * @param javadocTagMatcher found javadoc tag matcher
     * @param lineNumber line number of Javadoc tag in comment
     * @param startColumnNumber column number of Javadoc comment beginning
     * @return column number
     */
    private static int calculateTagColumn(Matcher javadocTagMatcher,
            int lineNumber, int startColumnNumber) {
<span class="fc" id="L726">        int col = javadocTagMatcher.start(1) - 1;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (lineNumber == 0) {</span>
<span class="fc" id="L728">            col += startColumnNumber;</span>
        }
<span class="fc" id="L730">        return col;</span>
    }

    /**
     * Gets multiline Javadoc tags with no arguments.
     * @param noargMultilineStart javadoc tag Matcher
     * @param lines comment text lines
     * @param lineIndex line number that contains the javadoc tag
     * @param tagLine javadoc tag line number in file
     * @return javadoc tags with no arguments
     */
    private static List&lt;JavadocTag&gt; getMultilineNoArgTags(final Matcher noargMultilineStart,
            final String[] lines, final int lineIndex, final int tagLine) {
<span class="fc" id="L743">        int remIndex = lineIndex;</span>
        Matcher multilineCont;

        do {
<span class="fc" id="L747">            remIndex++;</span>
<span class="fc" id="L748">            multilineCont = MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        } while (!multilineCont.find());</span>

<span class="fc" id="L751">        final List&lt;JavadocTag&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L752">        final String lFin = multilineCont.group(1);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        if (!lFin.equals(NEXT_TAG)</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            &amp;&amp; !lFin.equals(END_JAVADOC)) {</span>
<span class="fc" id="L755">            final String param1 = noargMultilineStart.group(1);</span>
<span class="fc" id="L756">            final int col = noargMultilineStart.start(1) - 1;</span>

<span class="fc" id="L758">            tags.add(new JavadocTag(tagLine, col, param1));</span>
        }

<span class="fc" id="L761">        return tags;</span>
    }

    /**
     * Computes the parameter nodes for a method.
     *
     * @param ast the method node.
     * @return the list of parameter nodes for ast.
     */
    private static List&lt;DetailAST&gt; getParameters(DetailAST ast) {
<span class="fc" id="L771">        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);</span>
<span class="fc" id="L772">        final List&lt;DetailAST&gt; returnValue = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L774">        DetailAST child = params.getFirstChild();</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        while (child != null) {</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (child.getType() == TokenTypes.PARAMETER_DEF) {</span>
<span class="fc" id="L777">                final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">                if (ident != null) {</span>
<span class="fc" id="L779">                    returnValue.add(ident);</span>
                }
            }
<span class="fc" id="L782">            child = child.getNextSibling();</span>
        }
<span class="fc" id="L784">        return returnValue;</span>
    }

    /**
     * Computes the exception nodes for a method.
     *
     * @param ast the method node.
     * @return the list of exception nodes for ast.
     */
    private List&lt;ExceptionInfo&gt; getThrows(DetailAST ast) {
<span class="fc" id="L794">        final List&lt;ExceptionInfo&gt; returnValue = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L795">        final DetailAST throwsAST = ast</span>
<span class="fc" id="L796">                .findFirstToken(TokenTypes.LITERAL_THROWS);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (throwsAST != null) {</span>
<span class="fc" id="L798">            DetailAST child = throwsAST.getFirstChild();</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">            while (child != null) {</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">                if (child.getType() == TokenTypes.IDENT</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">                        || child.getType() == TokenTypes.DOT) {</span>
<span class="fc" id="L802">                    final FullIdent ident = FullIdent.createFullIdent(child);</span>
<span class="fc" id="L803">                    final ExceptionInfo exceptionInfo = new ExceptionInfo(</span>
<span class="fc" id="L804">                            createClassInfo(new Token(ident), currentClassName));</span>
<span class="fc" id="L805">                    returnValue.add(exceptionInfo);</span>
                }
<span class="fc" id="L807">                child = child.getNextSibling();</span>
            }
        }
<span class="fc" id="L810">        return returnValue;</span>
    }

    /**
     * Checks a set of tags for matching parameters.
     *
     * @param tags the tags to check
     * @param parent the node which takes the parameters
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkParamTags(final List&lt;JavadocTag&gt; tags,
            final DetailAST parent, boolean reportExpectedTags) {
<span class="fc" id="L823">        final List&lt;DetailAST&gt; params = getParameters(parent);</span>
<span class="fc" id="L824">        final List&lt;DetailAST&gt; typeParams = CheckUtil</span>
<span class="fc" id="L825">                .getTypeParameters(parent);</span>

        // Loop over the tags, checking to see they exist in the params.
<span class="fc" id="L828">        final ListIterator&lt;JavadocTag&gt; tagIt = tags.listIterator();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        while (tagIt.hasNext()) {</span>
<span class="fc" id="L830">            final JavadocTag tag = tagIt.next();</span>

<span class="fc bfc" id="L832" title="All 2 branches covered.">            if (!tag.isParamTag()) {</span>
<span class="fc" id="L833">                continue;</span>
            }

<span class="fc" id="L836">            tagIt.remove();</span>

<span class="fc" id="L838">            final String arg1 = tag.getFirstArg();</span>
<span class="fc" id="L839">            boolean found = removeMatchingParam(params, arg1);</span>

<span class="fc bfc" id="L841" title="All 4 branches covered.">            if (CommonUtil.startsWithChar(arg1, '&lt;') &amp;&amp; CommonUtil.endsWithChar(arg1, '&gt;')) {</span>
<span class="fc" id="L842">                found = searchMatchingTypeParameter(typeParams,</span>
<span class="fc" id="L843">                        arg1.substring(1, arg1.length() - 1));</span>
            }

            // Handle extra JavadocTag
<span class="fc bfc" id="L847" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L848">                log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,</span>
                        &quot;@param&quot;, arg1);
            }
<span class="fc" id="L851">        }</span>

        // Now dump out all type parameters/parameters without tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L855" title="All 4 branches covered.">        if (!allowMissingParamTags &amp;&amp; reportExpectedTags) {</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">            for (DetailAST param : params) {</span>
<span class="fc" id="L857">                log(param, MSG_EXPECTED_TAG,</span>
<span class="fc" id="L858">                    JavadocTagInfo.PARAM.getText(), param.getText());</span>
<span class="fc" id="L859">            }</span>

<span class="fc bfc" id="L861" title="All 2 branches covered.">            for (DetailAST typeParam : typeParams) {</span>
<span class="fc" id="L862">                log(typeParam, MSG_EXPECTED_TAG,</span>
<span class="fc" id="L863">                    JavadocTagInfo.PARAM.getText(),</span>
<span class="fc" id="L864">                    &quot;&lt;&quot; + typeParam.findFirstToken(TokenTypes.IDENT).getText()</span>
                    + &quot;&gt;&quot;);
<span class="fc" id="L866">            }</span>
        }
<span class="fc" id="L868">    }</span>

    /**
     * Returns true if required type found in type parameters.
     * @param typeParams
     *            list of type parameters
     * @param requiredTypeName
     *            name of required type
     * @return true if required type found in type parameters.
     */
    private static boolean searchMatchingTypeParameter(List&lt;DetailAST&gt; typeParams,
            String requiredTypeName) {
        // Loop looking for matching type param
<span class="fc" id="L881">        final Iterator&lt;DetailAST&gt; typeParamsIt = typeParams.iterator();</span>
<span class="fc" id="L882">        boolean found = false;</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">        while (typeParamsIt.hasNext()) {</span>
<span class="fc" id="L884">            final DetailAST typeParam = typeParamsIt.next();</span>
<span class="fc" id="L885">            if (typeParam.findFirstToken(TokenTypes.IDENT).getText()</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">                    .equals(requiredTypeName)) {</span>
<span class="fc" id="L887">                found = true;</span>
<span class="fc" id="L888">                typeParamsIt.remove();</span>
<span class="fc" id="L889">                break;</span>
            }
<span class="fc" id="L891">        }</span>
<span class="fc" id="L892">        return found;</span>
    }

    /**
     * Remove parameter from params collection by name.
     * @param params collection of DetailAST parameters
     * @param paramName name of parameter
     * @return true if parameter found and removed
     */
    private static boolean removeMatchingParam(List&lt;DetailAST&gt; params, String paramName) {
<span class="fc" id="L902">        boolean found = false;</span>
<span class="fc" id="L903">        final Iterator&lt;DetailAST&gt; paramIt = params.iterator();</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">        while (paramIt.hasNext()) {</span>
<span class="fc" id="L905">            final DetailAST param = paramIt.next();</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">            if (param.getText().equals(paramName)) {</span>
<span class="fc" id="L907">                found = true;</span>
<span class="fc" id="L908">                paramIt.remove();</span>
<span class="fc" id="L909">                break;</span>
            }
<span class="fc" id="L911">        }</span>
<span class="fc" id="L912">        return found;</span>
    }

    /**
     * Checks for only one return tag. All return tags will be removed from the
     * supplied list.
     *
     * @param tags the tags to check
     * @param lineNo the line number of the expected tag
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkReturnTag(List&lt;JavadocTag&gt; tags, int lineNo,
        boolean reportExpectedTags) {
        // Loop over tags finding return tags. After the first one, report an
        // violation.
<span class="fc" id="L928">        boolean found = false;</span>
<span class="fc" id="L929">        final ListIterator&lt;JavadocTag&gt; it = tags.listIterator();</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L931">            final JavadocTag javadocTag = it.next();</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">            if (javadocTag.isReturnTag()) {</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L934">                    log(javadocTag.getLineNo(), javadocTag.getColumnNo(),</span>
                            MSG_DUPLICATE_TAG,
<span class="fc" id="L936">                            JavadocTagInfo.RETURN.getText());</span>
                }
<span class="fc" id="L938">                found = true;</span>
<span class="fc" id="L939">                it.remove();</span>
            }
<span class="fc" id="L941">        }</span>

        // Handle there being no @return tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L945" title="All 6 branches covered.">        if (!found &amp;&amp; !allowMissingReturnTag &amp;&amp; reportExpectedTags) {</span>
<span class="fc" id="L946">            log(lineNo, MSG_RETURN_EXPECTED);</span>
        }
<span class="fc" id="L948">    }</span>

    /**
     * Checks a set of tags for matching throws.
     *
     * @param tags the tags to check
     * @param throwsList the throws to check
     * @param reportExpectedTags whether we should report if do not find
     *            expected tag
     */
    private void checkThrowsTags(List&lt;JavadocTag&gt; tags,
            List&lt;ExceptionInfo&gt; throwsList, boolean reportExpectedTags) {
        // Loop over the tags, checking to see they exist in the throws.
        // The foundThrows used for performance only
<span class="fc" id="L962">        final Set&lt;String&gt; foundThrows = new HashSet&lt;&gt;();</span>
<span class="fc" id="L963">        final ListIterator&lt;JavadocTag&gt; tagIt = tags.listIterator();</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">        while (tagIt.hasNext()) {</span>
<span class="fc" id="L965">            final JavadocTag tag = tagIt.next();</span>

<span class="fc bfc" id="L967" title="All 2 branches covered.">            if (!tag.isThrowsTag()) {</span>
<span class="fc" id="L968">                continue;</span>
            }
<span class="fc" id="L970">            tagIt.remove();</span>

            // Loop looking for matching throw
<span class="fc" id="L973">            final String documentedEx = tag.getFirstArg();</span>
<span class="fc" id="L974">            final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag</span>
<span class="fc" id="L975">                    .getColumnNo());</span>
<span class="fc" id="L976">            final AbstractClassInfo documentedClassInfo = createClassInfo(token,</span>
                    currentClassName);
<span class="fc bfc" id="L978" title="All 2 branches covered.">            final boolean found = foundThrows.contains(documentedEx)</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                    || isInThrows(throwsList, documentedClassInfo, foundThrows);</span>

            // Handle extra JavadocTag.
<span class="fc bfc" id="L982" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L983">                boolean reqd = true;</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">                if (allowUndeclaredRTE) {</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">                    reqd = !isUnchecked(documentedClassInfo.getClazz());</span>
                }

<span class="fc bfc" id="L988" title="All 4 branches covered.">                if (reqd &amp;&amp; validateThrows) {</span>
<span class="fc" id="L989">                    log(tag.getLineNo(), tag.getColumnNo(),</span>
                        MSG_UNUSED_TAG,
<span class="fc" id="L991">                        JavadocTagInfo.THROWS.getText(), tag.getFirstArg());</span>
                }
            }
<span class="fc" id="L994">        }</span>
        // Now dump out all throws without tags :- unless
        // the user has chosen to suppress these problems
<span class="fc bfc" id="L997" title="All 4 branches covered.">        if (!allowMissingThrowsTags &amp;&amp; reportExpectedTags) {</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            throwsList.stream().filter(exceptionInfo -&gt; !exceptionInfo.isFound())</span>
<span class="fc" id="L999">                .forEach(exceptionInfo -&gt; {</span>
<span class="fc" id="L1000">                    final Token token = exceptionInfo.getName();</span>
<span class="fc" id="L1001">                    log(token.getLineNo(), token.getColumnNo(),</span>
                        MSG_EXPECTED_TAG,
<span class="fc" id="L1003">                        JavadocTagInfo.THROWS.getText(), token.getText());</span>
<span class="fc" id="L1004">                });</span>
        }
<span class="fc" id="L1006">    }</span>

    /**
     * Verifies that documented exception is in throws.
     *
     * @param throwsList list of throws
     * @param documentedClassInfo documented exception class info
     * @param foundThrows previously found throws
     * @return true if documented exception is in throws.
     */
    private boolean isInThrows(List&lt;ExceptionInfo&gt; throwsList,
            AbstractClassInfo documentedClassInfo, Set&lt;String&gt; foundThrows) {
<span class="fc" id="L1018">        boolean found = false;</span>
<span class="fc" id="L1019">        ExceptionInfo foundException = null;</span>

        // First look for matches on the exception name
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        for (ExceptionInfo exceptionInfo : throwsList) {</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">            if (exceptionInfo.getName().getText().equals(</span>
<span class="fc" id="L1024">                    documentedClassInfo.getName().getText())) {</span>
<span class="fc" id="L1025">                found = true;</span>
<span class="fc" id="L1026">                foundException = exceptionInfo;</span>
<span class="fc" id="L1027">                break;</span>
            }
<span class="fc" id="L1029">        }</span>

        // Now match on the exception type
<span class="fc" id="L1032">        final ListIterator&lt;ExceptionInfo&gt; exceptionInfoIt = throwsList.listIterator();</span>
<span class="fc bfc" id="L1033" title="All 4 branches covered.">        while (!found &amp;&amp; exceptionInfoIt.hasNext()) {</span>
<span class="fc" id="L1034">            final ExceptionInfo exceptionInfo = exceptionInfoIt.next();</span>

<span class="fc bfc" id="L1036" title="All 2 branches covered.">            if (documentedClassInfo.getClazz() == exceptionInfo.getClazz()) {</span>
<span class="fc" id="L1037">                found = true;</span>
<span class="fc" id="L1038">                foundException = exceptionInfo;</span>
            }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">            else if (allowThrowsTagsForSubclasses) {</span>
<span class="fc" id="L1041">                found = isSubclass(documentedClassInfo.getClazz(), exceptionInfo.getClazz());</span>
            }
<span class="fc" id="L1043">        }</span>

<span class="fc bfc" id="L1045" title="All 2 branches covered.">        if (foundException != null) {</span>
<span class="fc" id="L1046">            foundException.setFound();</span>
<span class="fc" id="L1047">            foundThrows.add(documentedClassInfo.getName().getText());</span>
        }

<span class="fc" id="L1050">        return found;</span>
    }

    /**
     * Is exception is unchecked (subclass of {@code RuntimeException}
     * or {@code Error}.
     *
     * @param exception {@code Class} of exception to check
     * @return true  if exception is unchecked
     *         false if exception is checked
     */
    private static boolean isUnchecked(Class&lt;?&gt; exception) {
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        return isSubclass(exception, RuntimeException.class)</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">            || isSubclass(exception, Error.class);</span>
    }

    /**
     * Checks if one class is subclass of another.
     *
     * @param child {@code Class} of class
     *               which should be child
     * @param parent {@code Class} of class
     *                which should be parent
     * @return true  if aChild is subclass of aParent
     *         false otherwise
     */
    private static boolean isSubclass(Class&lt;?&gt; child, Class&lt;?&gt; parent) {
<span class="fc bfc" id="L1077" title="All 4 branches covered.">        return parent != null &amp;&amp; child != null</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            &amp;&amp; parent.isAssignableFrom(child);</span>
    }

    /**
     * Returns the current tree's ClassResolver.
     * @return {@code ClassResolver} for current tree.
     */
    private ClassResolver getClassResolver() {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (classResolver == null) {</span>
<span class="fc" id="L1087">            classResolver =</span>
<span class="fc" id="L1088">                new ClassResolver(getClass().getClassLoader(),</span>
<span class="fc" id="L1089">                                  packageFullIdent.getText(),</span>
                                  imports);
        }
<span class="fc" id="L1092">        return classResolver;</span>
    }

    /**
     * Attempts to resolve the Class for a specified name.
     * @param resolvableClassName name of the class to resolve
     * @param className name of surrounding class.
     * @return the resolved class or {@code null}
     *          if unable to resolve the class.
     * @noinspection WeakerAccess
     */
    // -@cs[ForbidWildcardAsReturnType] The class is deprecated and will be removed soon.
    private Class&lt;?&gt; resolveClass(String resolvableClassName,
                                          String className) {
        Class&lt;?&gt; clazz;
        try {
<span class="fc" id="L1108">            clazz = getClassResolver().resolve(resolvableClassName, className);</span>
        }
        // -@cs[IllegalCatch] Exception type is not predictable.
<span class="fc" id="L1111">        catch (final Exception ignored) {</span>
<span class="fc" id="L1112">            clazz = null;</span>
<span class="fc" id="L1113">        }</span>
<span class="fc" id="L1114">        return clazz;</span>
    }

    /**
     * Tries to load class. Logs error if unable.
     * @param ident name of class which we try to load.
     * @param className name of surrounding class.
     * @return {@code Class} for a ident.
     * @noinspection WeakerAccess, MethodOnlyUsedFromInnerClass
     */
    // -@cs[ForbidWildcardAsReturnType] The class is deprecated and will be removed soon.
    private Class&lt;?&gt; tryLoadClass(Token ident, String className) {
<span class="fc" id="L1126">        return resolveClass(ident.getText(), className);</span>
    }

    /**
     * Collects the details of a package.
     * @param ast node containing the package details
     */
    private void processPackage(DetailAST ast) {
<span class="fc" id="L1134">        final DetailAST nameAST = ast.getLastChild().getPreviousSibling();</span>
<span class="fc" id="L1135">        packageFullIdent = FullIdent.createFullIdent(nameAST);</span>
<span class="fc" id="L1136">    }</span>

    /**
     * Collects the details of imports.
     * @param ast node containing the import details
     */
    private void processImport(DetailAST ast) {
<span class="fc" id="L1143">        final FullIdent name = FullIdent.createFullIdentBelow(ast);</span>
<span class="fc" id="L1144">        imports.add(name.getText());</span>
<span class="fc" id="L1145">    }</span>

    /**
     * Process type params (if any) for given class, enum or method.
     * @param ast class, enum or method to process.
     */
    private void processTypeParams(DetailAST ast) {
<span class="fc" id="L1152">        final DetailAST params =</span>
<span class="fc" id="L1153">            ast.findFirstToken(TokenTypes.TYPE_PARAMETERS);</span>

<span class="fc" id="L1155">        final Map&lt;String, AbstractClassInfo&gt; paramsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1156">        currentTypeParams.push(paramsMap);</span>

<span class="fc bfc" id="L1158" title="All 2 branches covered.">        if (params != null) {</span>
<span class="fc" id="L1159">            for (DetailAST child = params.getFirstChild();</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">                 child != null;</span>
<span class="fc" id="L1161">                 child = child.getNextSibling()) {</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                if (child.getType() == TokenTypes.TYPE_PARAMETER) {</span>
<span class="fc" id="L1163">                    final DetailAST bounds =</span>
<span class="fc" id="L1164">                        child.findFirstToken(TokenTypes.TYPE_UPPER_BOUNDS);</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">                    if (bounds != null) {</span>
<span class="fc" id="L1166">                        final FullIdent name =</span>
<span class="fc" id="L1167">                            FullIdent.createFullIdentBelow(bounds);</span>
<span class="fc" id="L1168">                        final AbstractClassInfo classInfo =</span>
<span class="fc" id="L1169">                            createClassInfo(new Token(name), currentClassName);</span>
<span class="fc" id="L1170">                        final String alias =</span>
<span class="fc" id="L1171">                                child.findFirstToken(TokenTypes.IDENT).getText();</span>
<span class="fc" id="L1172">                        paramsMap.put(alias, classInfo);</span>
                    }
                }
            }
        }
<span class="fc" id="L1177">    }</span>

    /**
     * Processes class definition.
     * @param ast class definition to process.
     */
    private void processClass(DetailAST ast) {
<span class="fc" id="L1184">        final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc" id="L1185">        String innerClass = ident.getText();</span>

<span class="fc bfc" id="L1187" title="All 2 branches covered.">        if (!currentClassName.isEmpty()) {</span>
<span class="fc" id="L1188">            innerClass = &quot;$&quot; + innerClass;</span>
        }
<span class="fc" id="L1190">        currentClassName += innerClass;</span>
<span class="fc" id="L1191">        processTypeParams(ast);</span>
<span class="fc" id="L1192">    }</span>

    /**
     * Creates class info for given name.
     * @param name name of type.
     * @param surroundingClass name of surrounding class.
     * @return class info for given name.
     */
    private AbstractClassInfo createClassInfo(final Token name,
                                              final String surroundingClass) {
        final AbstractClassInfo result;
<span class="fc" id="L1203">        final AbstractClassInfo classInfo = findClassAlias(name.getText());</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (classInfo == null) {</span>
<span class="fc" id="L1205">            result = new RegularClass(name, surroundingClass, this);</span>
        }
        else {
<span class="fc" id="L1208">            result = new ClassAlias(name, classInfo);</span>
        }
<span class="fc" id="L1210">        return result;</span>
    }

    /**
     * Looking if a given name is alias.
     * @param name given name
     * @return ClassInfo for alias if it exists, null otherwise
     * @noinspection WeakerAccess
     */
    private AbstractClassInfo findClassAlias(final String name) {
<span class="fc" id="L1220">        AbstractClassInfo classInfo = null;</span>
<span class="fc" id="L1221">        final Iterator&lt;Map&lt;String, AbstractClassInfo&gt;&gt; iterator = currentTypeParams</span>
<span class="fc" id="L1222">                .descendingIterator();</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L1224">            final Map&lt;String, AbstractClassInfo&gt; paramMap = iterator.next();</span>
<span class="fc" id="L1225">            classInfo = paramMap.get(name);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">            if (classInfo != null) {</span>
<span class="fc" id="L1227">                break;</span>
            }
<span class="fc" id="L1229">        }</span>
<span class="fc" id="L1230">        return classInfo;</span>
    }

    /**
     * Contains class's {@code Token}.
     */
    private abstract static class AbstractClassInfo {

        /** {@code FullIdent} associated with this class. */
        private final Token name;

        /**
         * Creates new instance of class information object.
         * @param className token which represents class name.
         */
<span class="fc" id="L1245">        protected AbstractClassInfo(final Token className) {</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">            if (className == null) {</span>
<span class="fc" id="L1247">                throw new IllegalArgumentException(</span>
                    &quot;ClassInfo's name should be non-null&quot;);
            }
<span class="fc" id="L1250">            name = className;</span>
<span class="fc" id="L1251">        }</span>

        /**
         * Returns class associated with that object.
         * @return {@code Class} associated with an object.
         */
        // -@cs[ForbidWildcardAsReturnType] The class is deprecated and will be removed soon.
        public abstract Class&lt;?&gt; getClazz();

        /**
         * Gets class name.
         * @return class name
         */
        public final Token getName() {
<span class="fc" id="L1265">            return name;</span>
        }

    }

    /** Represents regular classes/enums. */
    private static final class RegularClass extends AbstractClassInfo {

        /** Name of surrounding class. */
        private final String surroundingClass;
        /** The check we use to resolve classes. */
        private final JavadocMethodCheck check;
        /** Is class loadable. */
<span class="fc" id="L1278">        private boolean loadable = true;</span>
        /** {@code Class} object of this class if it's loadable. */
        private Class&lt;?&gt; classObj;

        /**
         * Creates new instance of of class information object.
         * @param name {@code FullIdent} associated with new object.
         * @param surroundingClass name of current surrounding class.
         * @param check the check we use to load class.
         */
        /* package */ RegularClass(final Token name,
                             final String surroundingClass,
                             final JavadocMethodCheck check) {
<span class="fc" id="L1291">            super(name);</span>
<span class="fc" id="L1292">            this.surroundingClass = surroundingClass;</span>
<span class="fc" id="L1293">            this.check = check;</span>
<span class="fc" id="L1294">        }</span>

        @Override
        public Class&lt;?&gt; getClazz() {
<span class="fc bfc" id="L1298" title="All 4 branches covered.">            if (loadable &amp;&amp; classObj == null) {</span>
<span class="fc" id="L1299">                setClazz(check.tryLoadClass(getName(), surroundingClass));</span>
            }
<span class="fc" id="L1301">            return classObj;</span>
        }

        /**
         * Associates {@code Class} with an object.
         * @param clazz {@code Class} to associate with.
         */
        private void setClazz(Class&lt;?&gt; clazz) {
<span class="fc" id="L1309">            classObj = clazz;</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            loadable = clazz != null;</span>
<span class="fc" id="L1311">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1315">            return &quot;RegularClass[name=&quot; + getName()</span>
                    + &quot;, in class='&quot; + surroundingClass + '\''
<span class="fc" id="L1317">                    + &quot;, check=&quot; + check.hashCode()</span>
                    + &quot;, loadable=&quot; + loadable
                    + &quot;, class=&quot; + classObj
                    + ']';
        }

    }

    /** Represents type param which is &quot;alias&quot; for real type. */
    private static class ClassAlias extends AbstractClassInfo {

        /** Class information associated with the alias. */
        private final AbstractClassInfo classInfo;

        /**
         * Creates new instance of the class.
         * @param name token which represents name of class alias.
         * @param classInfo class information associated with the alias.
         */
        /* package */ ClassAlias(final Token name, AbstractClassInfo classInfo) {
<span class="fc" id="L1337">            super(name);</span>
<span class="fc" id="L1338">            this.classInfo = classInfo;</span>
<span class="fc" id="L1339">        }</span>

        @Override
        public final Class&lt;?&gt; getClazz() {
<span class="fc" id="L1343">            return classInfo.getClazz();</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L1348">            return &quot;ClassAlias[alias &quot; + getName() + &quot; for &quot; + classInfo.getName() + &quot;]&quot;;</span>
        }

    }

    /**
     * Represents text element with location in the text.
     */
    private static class Token {

        /** Token's column number. */
        private final int columnNo;
        /** Token's line number. */
        private final int lineNo;
        /** Token's text. */
        private final String text;

        /**
         * Creates token.
         * @param text token's text
         * @param lineNo token's line number
         * @param columnNo token's column number
         */
<span class="fc" id="L1371">        /* default */ Token(String text, int lineNo, int columnNo) {</span>
<span class="fc" id="L1372">            this.text = text;</span>
<span class="fc" id="L1373">            this.lineNo = lineNo;</span>
<span class="fc" id="L1374">            this.columnNo = columnNo;</span>
<span class="fc" id="L1375">        }</span>

        /**
         * Converts FullIdent to Token.
         * @param fullIdent full ident to convert.
         */
<span class="fc" id="L1381">        /* default */ Token(FullIdent fullIdent) {</span>
<span class="fc" id="L1382">            text = fullIdent.getText();</span>
<span class="fc" id="L1383">            lineNo = fullIdent.getLineNo();</span>
<span class="fc" id="L1384">            columnNo = fullIdent.getColumnNo();</span>
<span class="fc" id="L1385">        }</span>

        /**
         * Gets line number of the token.
         * @return line number of the token
         */
        public int getLineNo() {
<span class="fc" id="L1392">            return lineNo;</span>
        }

        /**
         * Gets column number of the token.
         * @return column number of the token
         */
        public int getColumnNo() {
<span class="fc" id="L1400">            return columnNo;</span>
        }

        /**
         * Gets text of the token.
         * @return text of the token
         */
        public String getText() {
<span class="fc" id="L1408">            return text;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L1413">            return &quot;Token[&quot; + text + &quot;(&quot; + lineNo</span>
                + &quot;x&quot; + columnNo + &quot;)]&quot;;
        }

    }

    /** Stores useful information about declared exception. */
    private static class ExceptionInfo {

        /** Class information associated with this exception. */
        private final AbstractClassInfo classInfo;
        /** Does the exception have throws tag associated with. */
        private boolean found;

        /**
         * Creates new instance for {@code FullIdent}.
         *
         * @param classInfo class info
         */
<span class="fc" id="L1432">        /* package */ ExceptionInfo(AbstractClassInfo classInfo) {</span>
<span class="fc" id="L1433">            this.classInfo = classInfo;</span>
<span class="fc" id="L1434">        }</span>

        /** Mark that the exception has associated throws tag. */
        private void setFound() {
<span class="fc" id="L1438">            found = true;</span>
<span class="fc" id="L1439">        }</span>

        /**
         * Checks that the exception has throws tag associated with it.
         * @return whether the exception has throws tag associated with
         */
        private boolean isFound() {
<span class="fc" id="L1446">            return found;</span>
        }

        /**
         * Gets exception name.
         * @return exception's name
         */
        private Token getName() {
<span class="fc" id="L1454">            return classInfo.getName();</span>
        }

        /**
         * Gets exception class.
         * @return class for this exception
         */
        private Class&lt;?&gt; getClazz() {
<span class="fc" id="L1462">            return classInfo.getClazz();</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>