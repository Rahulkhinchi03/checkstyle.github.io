<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbbreviationAsWordInNameCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.naming</a> &gt; <span class="el_source">AbbreviationAsWordInNameCheck.java</span></div><h1>AbbreviationAsWordInNameCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.naming;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import com.puppycrawl.tools.checkstyle.StatelessCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
import com.puppycrawl.tools.checkstyle.utils.CommonUtils;

/**
 * &lt;p&gt;
 * The Check validate abbreviations(consecutive capital letters) length in
 * identifier name, it also allows to enforce camel case naming. Please read more at
 * &lt;a href=
 *  &quot;http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html#s5.3-camel-case&quot;&gt;
 * Google Style Guide&lt;/a&gt; to get to know how to avoid long abbreviations in names.
 * &lt;/p&gt;
 * &lt;p&gt;
 * {@code allowedAbbreviationLength} specifies how many consecutive capital letters are
 * allowed in the identifier.
 * A value of &lt;i&gt;3&lt;/i&gt; indicates that up to 4 consecutive capital letters are allowed,
 * one after the other, before a violation is printed. The identifier 'MyTEST' would be
 * allowed, but 'MyTESTS' would not be.
 * A value of &lt;i&gt;0&lt;/i&gt; indicates that only 1 consecutive capital letter is allowed. This
 * is what should be used to enforce strict camel casing. The identifier 'MyTest' would
 * be allowed, but 'MyTEst' would not be.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Option {@code allowedAbbreviationLength} indicates on the allowed amount of capital
 * letters in abbreviations in the classes, interfaces,
 * variables and methods names. Default value is '3'.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Option {@code allowedAbbreviations} - list of abbreviations that
 * must be skipped for checking. Abbreviations should be separated by comma,
 * no spaces are allowed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Option {@code ignoreFinal} allow to skip variables with {@code final} modifier.
 * Default value is {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Option {@code ignoreStatic} allow to skip variables with {@code static} modifier.
 * Default value is {@code true}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Option {@code ignoreOverriddenMethod} - Allows to
 * ignore methods tagged with {@code @Override} annotation
 * (that usually mean inherited name). Default value is {@code true}.
 * &lt;/p&gt;
 * Default configuration
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;AbbreviationAsWordInName&quot; /&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure to check variables and classes identifiers, do not ignore
 * variables with static modifier
 * and allow no abbreviations (enforce camel case phrase) but allow XML and URL abbreviations.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;AbbreviationAsWordInName&quot;&amp;gt;
 *     &amp;lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF,CLASS_DEF&quot;/&amp;gt;
 *     &amp;lt;property name=&quot;ignoreStatic&quot; value=&quot;false&quot;/&amp;gt;
 *     &amp;lt;property name=&quot;allowedAbbreviationLength&quot; value=&quot;1&quot;/&amp;gt;
 *     &amp;lt;property name=&quot;allowedAbbreviations&quot; value=&quot;XML,URL&quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 *
 */
@StatelessCheck
<span class="fc" id="L97">public class AbbreviationAsWordInNameCheck extends AbstractCheck {</span>

    /**
     * Warning message key.
     */
    public static final String MSG_KEY = &quot;abbreviation.as.word&quot;;

    /**
     * The default value of &quot;allowedAbbreviationLength&quot; option.
     */
    private static final int DEFAULT_ALLOWED_ABBREVIATIONS_LENGTH = 3;

    /**
     * Variable indicates on the allowed amount of capital letters in
     * abbreviations in the classes, interfaces, variables and methods names.
     */
<span class="fc" id="L113">    private int allowedAbbreviationLength =</span>
            DEFAULT_ALLOWED_ABBREVIATIONS_LENGTH;

    /**
     * Set of allowed abbreviation to ignore in check.
     */
<span class="fc" id="L119">    private Set&lt;String&gt; allowedAbbreviations = new HashSet&lt;&gt;();</span>

    /** Allows to ignore variables with 'final' modifier. */
<span class="fc" id="L122">    private boolean ignoreFinal = true;</span>

    /** Allows to ignore variables with 'static' modifier. */
<span class="fc" id="L125">    private boolean ignoreStatic = true;</span>

    /** Allows to ignore methods with '@Override' annotation. */
<span class="fc" id="L128">    private boolean ignoreOverriddenMethods = true;</span>

    /**
     * Sets ignore option for variables with 'final' modifier.
     * @param ignoreFinal
     *        Defines if ignore variables with 'final' modifier or not.
     */
    public void setIgnoreFinal(boolean ignoreFinal) {
<span class="fc" id="L136">        this.ignoreFinal = ignoreFinal;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Sets ignore option for variables with 'static' modifier.
     * @param ignoreStatic
     *        Defines if ignore variables with 'static' modifier or not.
     */
    public void setIgnoreStatic(boolean ignoreStatic) {
<span class="fc" id="L145">        this.ignoreStatic = ignoreStatic;</span>
<span class="fc" id="L146">    }</span>

    /**
     * Sets ignore option for methods with &quot;@Override&quot; annotation.
     * @param ignoreOverriddenMethods
     *        Defines if ignore methods with &quot;@Override&quot; annotation or not.
     */
    public void setIgnoreOverriddenMethods(boolean ignoreOverriddenMethods) {
<span class="fc" id="L154">        this.ignoreOverriddenMethods = ignoreOverriddenMethods;</span>
<span class="fc" id="L155">    }</span>

    /**
     * Allowed abbreviation length in names.
     * @param allowedAbbreviationLength
     *            amount of allowed capital letters in abbreviation.
     */
    public void setAllowedAbbreviationLength(int allowedAbbreviationLength) {
<span class="fc" id="L163">        this.allowedAbbreviationLength = allowedAbbreviationLength;</span>
<span class="fc" id="L164">    }</span>

    /**
     * Set a list of abbreviations that must be skipped for checking.
     * Abbreviations should be separated by comma, no spaces is allowed.
     * @param allowedAbbreviations
     *        an string of abbreviations that must be skipped from checking,
     *        each abbreviation separated by comma.
     */
    public void setAllowedAbbreviations(String... allowedAbbreviations) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (allowedAbbreviations != null) {</span>
<span class="fc" id="L175">            this.allowedAbbreviations =</span>
<span class="fc" id="L176">                Arrays.stream(allowedAbbreviations).collect(Collectors.toSet());</span>
        }
<span class="fc" id="L178">    }</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L182">        return new int[] {</span>
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.ANNOTATION_DEF,
            TokenTypes.ANNOTATION_FIELD_DEF,
            TokenTypes.PARAMETER_DEF,
            TokenTypes.VARIABLE_DEF,
            TokenTypes.METHOD_DEF,
        };
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L196">        return new int[] {</span>
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.ANNOTATION_DEF,
            TokenTypes.ANNOTATION_FIELD_DEF,
            TokenTypes.PARAMETER_DEF,
            TokenTypes.VARIABLE_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.ENUM_CONSTANT_DEF,
        };
    }

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L211">        return CommonUtils.EMPTY_INT_ARRAY;</span>
    }

    @Override
    public void visitToken(DetailAST ast) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (!isIgnoreSituation(ast)) {</span>
<span class="fc" id="L217">            final DetailAST nameAst = ast.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc" id="L218">            final String typeName = nameAst.getText();</span>

<span class="fc" id="L220">            final String abbr = getDisallowedAbbreviation(typeName);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (abbr != null) {</span>
<span class="fc" id="L222">                log(nameAst.getLineNo(), MSG_KEY, typeName, allowedAbbreviationLength + 1);</span>
            }
        }
<span class="fc" id="L225">    }</span>

    /**
     * Checks if it is an ignore situation.
     * @param ast input DetailAST node.
     * @return true if it is an ignore situation found for given input DetailAST
     *         node.
     * @noinspection SimplifiableIfStatement
     */
    private boolean isIgnoreSituation(DetailAST ast) {
<span class="fc" id="L235">        final DetailAST modifiers = ast.getFirstChild();</span>

        final boolean result;
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (ast.getType() == TokenTypes.VARIABLE_DEF) {</span>
<span class="fc bfc" id="L239" title="All 4 branches covered.">            if ((ignoreFinal || ignoreStatic)</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                    &amp;&amp; isInterfaceDeclaration(ast)) {</span>
                // field declarations in interface are static/final
<span class="fc" id="L242">                result = true;</span>
            }
            else {
<span class="fc bfc" id="L245" title="All 2 branches covered.">                result = ignoreFinal</span>
<span class="fc bfc" id="L246" title="All 4 branches covered.">                          &amp;&amp; modifiers.findFirstToken(TokenTypes.FINAL) != null</span>
                    || ignoreStatic
<span class="fc bfc" id="L248" title="All 2 branches covered.">                        &amp;&amp; modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;</span>
            }
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        else if (ast.getType() == TokenTypes.METHOD_DEF) {</span>
<span class="fc bfc" id="L252" title="All 4 branches covered.">            result = ignoreOverriddenMethods &amp;&amp; hasOverrideAnnotation(modifiers);</span>
        }
        else {
<span class="fc" id="L255">            result = CheckUtils.isReceiverParameter(ast);</span>
        }
<span class="fc" id="L257">        return result;</span>
    }

    /**
     * Check that variable definition in interface or @interface definition.
     * @param variableDefAst variable definition.
     * @return true if variable definition(variableDefAst) is in interface
     *     or @interface definition.
     */
    private static boolean isInterfaceDeclaration(DetailAST variableDefAst) {
<span class="fc" id="L267">        boolean result = false;</span>
<span class="fc" id="L268">        final DetailAST astBlock = variableDefAst.getParent();</span>
<span class="fc" id="L269">        final DetailAST astParent2 = astBlock.getParent();</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (astParent2.getType() == TokenTypes.INTERFACE_DEF</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                || astParent2.getType() == TokenTypes.ANNOTATION_DEF) {</span>
<span class="fc" id="L273">            result = true;</span>
        }
<span class="fc" id="L275">        return result;</span>
    }

    /**
     * Checks that the method has &quot;@Override&quot; annotation.
     * @param methodModifiersAST
     *        A DetailAST nod is related to the given method modifiers
     *        (MODIFIERS type).
     * @return true if method has &quot;@Override&quot; annotation.
     */
    private static boolean hasOverrideAnnotation(DetailAST methodModifiersAST) {
<span class="fc" id="L286">        boolean result = false;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (DetailAST child : getChildren(methodModifiersAST)) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (child.getType() == TokenTypes.ANNOTATION) {</span>
<span class="fc" id="L289">                final DetailAST annotationIdent = child.findFirstToken(TokenTypes.IDENT);</span>

<span class="fc bfc" id="L291" title="All 4 branches covered.">                if (annotationIdent != null &amp;&amp; &quot;Override&quot;.equals(annotationIdent.getText())) {</span>
<span class="fc" id="L292">                    result = true;</span>
<span class="fc" id="L293">                    break;</span>
                }
            }
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">        return result;</span>
    }

    /**
     * Gets the disallowed abbreviation contained in given String.
     * @param str
     *        the given String.
     * @return the disallowed abbreviation contained in given String as a
     *         separate String.
     */
    private String getDisallowedAbbreviation(String str) {
<span class="fc" id="L308">        int beginIndex = 0;</span>
<span class="fc" id="L309">        boolean abbrStarted = false;</span>
<span class="fc" id="L310">        String result = null;</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int index = 0; index &lt; str.length(); index++) {</span>
<span class="fc" id="L313">            final char symbol = str.charAt(index);</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (Character.isUpperCase(symbol)) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                if (!abbrStarted) {</span>
<span class="fc" id="L317">                    abbrStarted = true;</span>
<span class="fc" id="L318">                    beginIndex = index;</span>
                }
            }
<span class="fc bfc" id="L321" title="All 2 branches covered.">            else if (abbrStarted) {</span>
<span class="fc" id="L322">                abbrStarted = false;</span>

<span class="fc" id="L324">                final int endIndex = index - 1;</span>
                // -1 as a first capital is usually beginning of next word
<span class="fc" id="L326">                result = getAbbreviationIfIllegal(str, beginIndex, endIndex);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                if (result != null) {</span>
<span class="fc" id="L328">                    break;</span>
                }
<span class="fc" id="L330">                beginIndex = -1;</span>
            }
        }
        // if abbreviation at the end of name and it is not single character (example: scaleX)
<span class="fc bfc" id="L334" title="All 4 branches covered.">        if (abbrStarted &amp;&amp; beginIndex != str.length() - 1) {</span>
<span class="fc" id="L335">            final int endIndex = str.length();</span>
<span class="fc" id="L336">            result = getAbbreviationIfIllegal(str, beginIndex, endIndex);</span>
        }
<span class="fc" id="L338">        return result;</span>
    }

    /**
     * Get Abbreviation if it is illegal.
     * @param str name
     * @param beginIndex begin index
     * @param endIndex end index
     * @return true is abbreviation is bigger that required and not in ignore list
     */
    private String getAbbreviationIfIllegal(String str, int beginIndex, int endIndex) {
<span class="fc" id="L349">        String result = null;</span>
<span class="fc" id="L350">        final int abbrLength = endIndex - beginIndex;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (abbrLength &gt; allowedAbbreviationLength) {</span>
<span class="fc" id="L352">            final String abbr = str.substring(beginIndex, endIndex);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (!allowedAbbreviations.contains(abbr)) {</span>
<span class="fc" id="L354">                result = abbr;</span>
            }
        }
<span class="fc" id="L357">        return result;</span>
    }

    /**
     * Gets all the children which are one level below on the current DetailAST
     * parent node.
     * @param node
     *        Current parent node.
     * @return The list of children one level below on the current parent node.
     */
    private static List&lt;DetailAST&gt; getChildren(final DetailAST node) {
<span class="fc" id="L368">        final List&lt;DetailAST&gt; result = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L369">        DetailAST curNode = node.getFirstChild();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        while (curNode != null) {</span>
<span class="fc" id="L371">            result.add(curNode);</span>
<span class="fc" id="L372">            curNode = curNode.getNextSibling();</span>
        }
<span class="fc" id="L374">        return result;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>