<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.logging.ConsoleHandler;
import java.util.logging.Filter;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.puppycrawl.tools.checkstyle.api.AuditEvent;
import com.puppycrawl.tools.checkstyle.api.AuditListener;
import com.puppycrawl.tools.checkstyle.api.AutomaticBean;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;
import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
import com.puppycrawl.tools.checkstyle.api.RootModule;
import com.puppycrawl.tools.checkstyle.utils.CommonUtils;

/**
 * Wrapper command line program for the Checker.
 * @noinspection UseOfSystemOutOrSystemErr
 **/
public final class Main {

    /**
     * A key pointing to the error counter
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String ERROR_COUNTER = &quot;Main.errorCounter&quot;;
    /**
     * A key pointing to the load properties exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String LOAD_PROPERTIES_EXCEPTION = &quot;Main.loadProperties&quot;;
    /**
     * A key pointing to the create listener exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String CREATE_LISTENER_EXCEPTION = &quot;Main.createListener&quot;;
    /** Logger for Main. */
<span class="fc" id="L79">    private static final Log LOG = LogFactory.getLog(Main.class);</span>

    /** Width of CLI help option. */
    private static final int HELP_WIDTH = 100;

    /** Exit code returned when execution finishes with {@link CheckstyleException}. */
    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;

    /** Name for the option 'v'. */
    private static final String OPTION_V_NAME = &quot;v&quot;;

    /** Name for the option 'c'. */
    private static final String OPTION_C_NAME = &quot;c&quot;;

    /** Name for the option 'f'. */
    private static final String OPTION_F_NAME = &quot;f&quot;;

    /** Name for the option 'p'. */
    private static final String OPTION_P_NAME = &quot;p&quot;;

    /** Name for the option 'o'. */
    private static final String OPTION_O_NAME = &quot;o&quot;;

    /** Name for the option 's'. */
    private static final String OPTION_S_NAME = &quot;s&quot;;

    /** Name for the option 't'. */
    private static final String OPTION_T_NAME = &quot;t&quot;;

    /** Name for the option '--tree'. */
    private static final String OPTION_TREE_NAME = &quot;tree&quot;;

    /** Name for the option 'tabWidth'. */
    private static final String OPTION_TAB_WIDTH_NAME = &quot;tabWidth&quot;;

    /** Name for the option '-T'. */
    private static final String OPTION_CAPITAL_T_NAME = &quot;T&quot;;

    /** Name for the option '--treeWithComments'. */
    private static final String OPTION_TREE_COMMENT_NAME = &quot;treeWithComments&quot;;

    /** Name for the option '-j'. */
    private static final String OPTION_J_NAME = &quot;j&quot;;

    /** Name for the option '--javadocTree'. */
    private static final String OPTION_JAVADOC_TREE_NAME = &quot;javadocTree&quot;;

    /** Name for the option '-J'. */
    private static final String OPTION_CAPITAL_J_NAME = &quot;J&quot;;

    /** Name for the option '--treeWithJavadoc'. */
    private static final String OPTION_TREE_JAVADOC_NAME = &quot;treeWithJavadoc&quot;;

    /** Name for the option '-d'. */
    private static final String OPTION_D_NAME = &quot;d&quot;;

    /** Name for the option '--debug'. */
    private static final String OPTION_DEBUG_NAME = &quot;debug&quot;;

    /** Name for the option 'e'. */
    private static final String OPTION_E_NAME = &quot;e&quot;;

    /** Name for the option '--exclude'. */
    private static final String OPTION_EXCLUDE_NAME = &quot;exclude&quot;;

    /** Name for the option '--executeIgnoredModules'. */
    private static final String OPTION_EXECUTE_IGNORED_MODULES_NAME = &quot;executeIgnoredModules&quot;;

    /** Name for the option 'x'. */
    private static final String OPTION_X_NAME = &quot;x&quot;;

    /** Name for the option '--exclude-regexp'. */
    private static final String OPTION_EXCLUDE_REGEXP_NAME = &quot;exclude-regexp&quot;;

    /** Name for the option '-C'. */
    private static final String OPTION_CAPITAL_C_NAME = &quot;C&quot;;

    /** Name for the option '--checker-threads-number'. */
    private static final String OPTION_CHECKER_THREADS_NUMBER_NAME = &quot;checker-threads-number&quot;;

    /** Name for the option '-W'. */
    private static final String OPTION_CAPITAL_W_NAME = &quot;W&quot;;

    /** Name for the option '--tree-walker-threads-number'. */
    private static final String OPTION_TREE_WALKER_THREADS_NUMBER_NAME =
        &quot;tree-walker-threads-number&quot;;

    /** Name for 'xml' format. */
    private static final String XML_FORMAT_NAME = &quot;xml&quot;;

    /** Name for 'plain' format. */
    private static final String PLAIN_FORMAT_NAME = &quot;plain&quot;;

    /** A string value of 1. */
    private static final String ONE_STRING_VALUE = &quot;1&quot;;

    /** Default distance between tab stops. */
    private static final String DEFAULT_TAB_WIDTH = &quot;8&quot;;

    /** Don't create instance of this class, use {@link #main(String[])} method instead. */
    private Main() {
    }

    /**
     * Loops over the files specified checking them for errors. The exit code
     * is the number of errors found in all the files.
     * @param args the command line arguments.
     * @throws IOException if there is a problem with files access
     * @noinspection CallToPrintStackTrace, CallToSystemExit
     **/
    public static void main(String... args) throws IOException {
<span class="fc" id="L190">        int errorCounter = 0;</span>
<span class="fc" id="L191">        boolean cliViolations = false;</span>
        // provide proper exit code based on results.
<span class="fc" id="L193">        final int exitWithCliViolation = -1;</span>
<span class="fc" id="L194">        int exitStatus = 0;</span>

        try {
            //parse CLI arguments
<span class="fc" id="L198">            final CommandLine commandLine = parseCli(args);</span>

            // show version and exit if it is requested
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_V_NAME)) {</span>
<span class="fc" id="L202">                System.out.println(&quot;Checkstyle version: &quot;</span>
<span class="fc" id="L203">                        + Main.class.getPackage().getImplementationVersion());</span>
<span class="fc" id="L204">                exitStatus = 0;</span>
            }
            else {
<span class="fc" id="L207">                final List&lt;File&gt; filesToProcess = getFilesToProcess(getExclusions(commandLine),</span>
<span class="fc" id="L208">                        commandLine.getArgs());</span>

                // return error if something is wrong in arguments
<span class="fc" id="L211">                final List&lt;String&gt; messages = validateCli(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                cliViolations = !messages.isEmpty();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                if (cliViolations) {</span>
<span class="fc" id="L214">                    exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L215">                    errorCounter = 1;</span>
<span class="fc" id="L216">                    messages.forEach(System.out::println);</span>
                }
                else {
<span class="fc" id="L219">                    errorCounter = runCli(commandLine, filesToProcess);</span>
<span class="fc" id="L220">                    exitStatus = errorCounter;</span>
                }
            }
        }
<span class="fc" id="L224">        catch (ParseException pex) {</span>
            // something wrong with arguments - print error and manual
<span class="fc" id="L226">            cliViolations = true;</span>
<span class="fc" id="L227">            exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L228">            errorCounter = 1;</span>
<span class="fc" id="L229">            System.out.println(pex.getMessage());</span>
<span class="fc" id="L230">            printUsage();</span>
        }
<span class="fc" id="L232">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L233">            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;</span>
<span class="fc" id="L234">            errorCounter = 1;</span>
<span class="fc" id="L235">            ex.printStackTrace();</span>
        }
        finally {
            // return exit code base on validation of Checker
            // two ifs exist till https://github.com/hcoles/pitest/issues/377
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (errorCounter != 0) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (!cliViolations) {</span>
<span class="fc" id="L242">                    final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,</span>
                            Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,
<span class="fc" id="L244">                            new String[] {String.valueOf(errorCounter)}, null, Main.class, null);</span>
<span class="fc" id="L245">                    System.out.println(errorCounterMessage.getMessage());</span>
                }
            }
<span class="fc bfc" id="L248" title="All 2 branches covered.">            if (exitStatus != 0) {</span>
<span class="fc" id="L249">                System.exit(exitStatus);</span>
            }
        }
<span class="fc" id="L252">    }</span>

    /**
     * Parses and executes Checkstyle based on passed arguments.
     * @param args
     *        command line parameters
     * @return parsed information about passed parameters
     * @throws ParseException
     *         when passed arguments are not valid
     */
    private static CommandLine parseCli(String... args)
            throws ParseException {
        // parse the parameters
<span class="fc" id="L265">        final CommandLineParser clp = new DefaultParser();</span>
        // always returns not null value
<span class="fc" id="L267">        return clp.parse(buildOptions(), args);</span>
    }

    /**
     * Gets the list of exclusions provided through the command line argument.
     * @param commandLine command line object
     * @return List of exclusion patterns.
     */
    private static List&lt;Pattern&gt; getExclusions(CommandLine commandLine) {
<span class="fc" id="L276">        final List&lt;Pattern&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_E_NAME)) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_E_NAME)) {</span>
<span class="fc" id="L280">                result.add(Pattern.compile(&quot;^&quot; + Pattern.quote(new File(value).getAbsolutePath())</span>
                        + &quot;$&quot;));
            }
        }
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_X_NAME)) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_X_NAME)) {</span>
<span class="fc" id="L286">                result.add(Pattern.compile(value));</span>
            }
        }

<span class="fc" id="L290">        return result;</span>
    }

    /**
     * Do validation of Command line options.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return list of violations
     */
    // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation
    private static List&lt;String&gt; validateCli(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L301">        final List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (filesToProcess.isEmpty()) {</span>
<span class="fc" id="L304">            result.add(&quot;Files to process must be specified, found 0.&quot;);</span>
        }
        // ensure there is no conflicting options
<span class="fc bfc" id="L307" title="All 4 branches covered.">        else if (cmdLine.hasOption(OPTION_T_NAME) || cmdLine.hasOption(OPTION_CAPITAL_T_NAME)</span>
<span class="fc bfc" id="L308" title="All 4 branches covered.">                || cmdLine.hasOption(OPTION_J_NAME) || cmdLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">            if (cmdLine.hasOption(OPTION_S_NAME) || cmdLine.hasOption(OPTION_C_NAME)</span>
<span class="fc bfc" id="L310" title="All 4 branches covered.">                    || cmdLine.hasOption(OPTION_P_NAME) || cmdLine.hasOption(OPTION_F_NAME)</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                    || cmdLine.hasOption(OPTION_O_NAME)) {</span>
<span class="fc" id="L312">                result.add(&quot;Option '-t' cannot be used with other options.&quot;);</span>
            }
<span class="fc bfc" id="L314" title="All 2 branches covered.">            else if (filesToProcess.size() &gt; 1) {</span>
<span class="fc" id="L315">                result.add(&quot;Printing AST is allowed for only one file.&quot;);</span>
            }
        }
<span class="fc bfc" id="L318" title="All 2 branches covered.">        else if (cmdLine.hasOption(OPTION_S_NAME)) {</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">            if (cmdLine.hasOption(OPTION_C_NAME) || cmdLine.hasOption(OPTION_P_NAME)</span>
<span class="fc bfc" id="L320" title="All 4 branches covered.">                    || cmdLine.hasOption(OPTION_F_NAME) || cmdLine.hasOption(OPTION_O_NAME)) {</span>
<span class="fc" id="L321">                result.add(&quot;Option '-s' cannot be used with other options.&quot;);</span>
            }
<span class="fc bfc" id="L323" title="All 2 branches covered.">            else if (filesToProcess.size() &gt; 1) {</span>
<span class="fc" id="L324">                result.add(&quot;Printing xpath suppressions is allowed for only one file.&quot;);</span>
            }
        }
        // ensure a configuration file is specified
<span class="fc bfc" id="L328" title="All 2 branches covered.">        else if (cmdLine.hasOption(OPTION_C_NAME)) {</span>
<span class="fc" id="L329">            final String configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
            try {
                // test location only
<span class="fc" id="L332">                CommonUtils.getUriByFilename(configLocation);</span>
            }
<span class="fc" id="L334">            catch (CheckstyleException ignored) {</span>
<span class="fc" id="L335">                result.add(String.format(&quot;Could not find config XML file '%s'.&quot;, configLocation));</span>
<span class="fc" id="L336">            }</span>

            // validate optional parameters
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_F_NAME)) {</span>
<span class="fc" id="L340">                final String format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L341" title="All 4 branches covered.">                if (!PLAIN_FORMAT_NAME.equals(format) &amp;&amp; !XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L342">                    result.add(String.format(&quot;Invalid output format.&quot;</span>
                            + &quot; Found '%s' but expected '%s' or '%s'.&quot;,
                            format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME));
                }
            }
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_P_NAME)) {</span>
<span class="fc" id="L348">                final String propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L349">                final File file = new File(propertiesLocation);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                if (!file.exists()) {</span>
<span class="fc" id="L351">                    result.add(String.format(&quot;Could not find file '%s'.&quot;, propertiesLocation));</span>
                }
            }
<span class="fc" id="L354">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_C_NAME,</span>
                &quot;Checker threads number must be greater than zero&quot;,
                &quot;Invalid Checker threads number&quot;);
<span class="fc" id="L357">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_W_NAME,</span>
                &quot;TreeWalker threads number must be greater than zero&quot;,
                &quot;Invalid TreeWalker threads number&quot;);
<span class="fc" id="L360">        }</span>
        else {
<span class="fc" id="L362">            result.add(&quot;Must specify a config XML file.&quot;);</span>
        }

<span class="fc" id="L365">        return result;</span>
    }

    /**
     * Verifies threads number CLI parameter value.
     * @param cmdLine a command line
     * @param result a resulting list of errors
     * @param cliParameterName a CLI parameter name
     * @param mustBeGreaterThanZeroMessage a message which should be reported
     *                                     if the number of threads is less than or equal to zero
     * @param invalidNumberMessage a message which should be reported if the passed value
     *                             is not a valid number
     */
    private static void verifyThreadsNumberParameter(CommandLine cmdLine, List&lt;String&gt; result,
        String cliParameterName, String mustBeGreaterThanZeroMessage,
        String invalidNumberMessage) {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (cmdLine.hasOption(cliParameterName)) {</span>
<span class="fc" id="L382">            final String checkerThreadsNumberStr =</span>
<span class="fc" id="L383">                cmdLine.getOptionValue(cliParameterName);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (CommonUtils.isInt(checkerThreadsNumberStr)) {</span>
<span class="fc" id="L385">                final int checkerThreadsNumber = Integer.parseInt(checkerThreadsNumberStr);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                if (checkerThreadsNumber &lt; 1) {</span>
<span class="fc" id="L387">                    result.add(mustBeGreaterThanZeroMessage);</span>
                }
<span class="fc" id="L389">            }</span>
            else {
<span class="fc" id="L391">                result.add(invalidNumberMessage);</span>
            }
        }
<span class="fc" id="L394">    }</span>

    /**
     * Do execution of CheckStyle based on Command line options.
     * @param commandLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return number of violations
     * @throws IOException if a file could not be read.
     * @throws CheckstyleException if something happens processing the files.
     */
    private static int runCli(CommandLine commandLine, List&lt;File&gt; filesToProcess)
            throws IOException, CheckstyleException {
<span class="fc" id="L406">        int result = 0;</span>

        // create config helper object
<span class="fc" id="L409">        final CliOptions config = convertCliToPojo(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_T_NAME)) {</span>
            // print AST
<span class="fc" id="L412">            final File file = config.files.get(0);</span>
<span class="fc" id="L413">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITHOUT_COMMENTS);
<span class="fc" id="L415">            System.out.print(stringAst);</span>
<span class="fc" id="L416">        }</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {</span>
<span class="fc" id="L418">            final File file = config.files.get(0);</span>
<span class="fc" id="L419">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITH_COMMENTS);
<span class="fc" id="L421">            System.out.print(stringAst);</span>
<span class="fc" id="L422">        }</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_J_NAME)) {</span>
<span class="fc" id="L424">            final File file = config.files.get(0);</span>
<span class="fc" id="L425">            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);</span>
<span class="fc" id="L426">            System.out.print(stringAst);</span>
<span class="fc" id="L427">        }</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc" id="L429">            final File file = config.files.get(0);</span>
<span class="fc" id="L430">            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);</span>
<span class="fc" id="L431">            System.out.print(stringAst);</span>
<span class="fc" id="L432">        }</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_S_NAME)) {</span>
<span class="fc" id="L434">            final File file = config.files.get(0);</span>
<span class="fc" id="L435">            final String suppressionLineColumnNumber = config.suppressionLineColumnNumber;</span>
<span class="fc" id="L436">            final int tabWidth = config.tabWidth;</span>
<span class="fc" id="L437">            final String stringSuppressions =</span>
<span class="fc" id="L438">                    SuppressionsStringPrinter.printSuppressions(file,</span>
                            suppressionLineColumnNumber, tabWidth);
<span class="fc" id="L440">            System.out.print(stringSuppressions);</span>
<span class="fc" id="L441">        }</span>
        else {
<span class="fc bfc" id="L443" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_D_NAME)) {</span>
<span class="fc" id="L444">                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();</span>
<span class="fc" id="L445">                final ConsoleHandler handler = new ConsoleHandler();</span>
<span class="fc" id="L446">                handler.setLevel(Level.FINEST);</span>
<span class="fc" id="L447">                handler.setFilter(new Filter() {</span>
<span class="fc" id="L448">                    private final String packageName = Main.class.getPackage().getName();</span>

                    @Override
                    public boolean isLoggable(LogRecord record) {
<span class="fc" id="L452">                        return record.getLoggerName().startsWith(packageName);</span>
                    }
                });
<span class="fc" id="L455">                parentLogger.addHandler(handler);</span>
<span class="fc" id="L456">                parentLogger.setLevel(Level.FINEST);</span>
            }
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (LOG.isDebugEnabled()) {</span>
<span class="fc" id="L459">                LOG.debug(&quot;Checkstyle debug logging enabled&quot;);</span>
<span class="fc" id="L460">                LOG.debug(&quot;Running Checkstyle with version: &quot;</span>
<span class="fc" id="L461">                        + Main.class.getPackage().getImplementationVersion());</span>
            }

            // run Checker
<span class="fc" id="L465">            result = runCheckstyle(config);</span>
        }

<span class="fc" id="L468">        return result;</span>
    }

    /**
     * Util method to convert CommandLine type to POJO object.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return command line option as POJO object
     */
    private static CliOptions convertCliToPojo(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L478">        final CliOptions conf = new CliOptions();</span>
<span class="fc" id="L479">        conf.format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (conf.format == null) {</span>
<span class="fc" id="L481">            conf.format = PLAIN_FORMAT_NAME;</span>
        }
<span class="fc" id="L483">        conf.outputLocation = cmdLine.getOptionValue(OPTION_O_NAME);</span>
<span class="fc" id="L484">        conf.configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
<span class="fc" id="L485">        conf.propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L486">        conf.suppressionLineColumnNumber = cmdLine.getOptionValue(OPTION_S_NAME);</span>
<span class="fc" id="L487">        conf.files = filesToProcess;</span>
<span class="fc" id="L488">        conf.executeIgnoredModules = cmdLine.hasOption(OPTION_EXECUTE_IGNORED_MODULES_NAME);</span>
<span class="fc" id="L489">        final String checkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_C_NAME, ONE_STRING_VALUE);
<span class="fc" id="L491">        conf.checkerThreadsNumber = Integer.parseInt(checkerThreadsNumber);</span>
<span class="fc" id="L492">        final String treeWalkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_W_NAME, ONE_STRING_VALUE);
<span class="fc" id="L494">        conf.treeWalkerThreadsNumber = Integer.parseInt(treeWalkerThreadsNumber);</span>
<span class="fc" id="L495">        final String tabWidth =</span>
<span class="fc" id="L496">                cmdLine.getOptionValue(OPTION_TAB_WIDTH_NAME, DEFAULT_TAB_WIDTH);</span>
<span class="fc" id="L497">        conf.tabWidth = Integer.parseInt(tabWidth);</span>
<span class="fc" id="L498">        return conf;</span>
    }

    /**
     * Executes required Checkstyle actions based on passed parameters.
     * @param cliOptions
     *        pojo object that contains all options
     * @return number of violations of ERROR level
     * @throws IOException
     *         when output file could not be found
     * @throws CheckstyleException
     *         when properties file could not be loaded
     */
    private static int runCheckstyle(CliOptions cliOptions)
            throws CheckstyleException, IOException {
        // setup the properties
        final Properties props;

<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (cliOptions.propertiesLocation == null) {</span>
<span class="fc" id="L517">            props = System.getProperties();</span>
        }
        else {
<span class="fc" id="L520">            props = loadProperties(new File(cliOptions.propertiesLocation));</span>
        }

        // create a configuration
<span class="fc" id="L524">        final ThreadModeSettings multiThreadModeSettings =</span>
                new ThreadModeSettings(
<span class="fc" id="L526">                        cliOptions.checkerThreadsNumber, cliOptions.treeWalkerThreadsNumber);</span>

        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (cliOptions.executeIgnoredModules) {</span>
<span class="fc" id="L530">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;</span>
        }
        else {
<span class="fc" id="L533">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;</span>
        }

<span class="fc" id="L536">        final Configuration config = ConfigurationLoader.loadConfiguration(</span>
<span class="fc" id="L537">                cliOptions.configLocation, new PropertiesExpander(props),</span>
                ignoredModulesOptions, multiThreadModeSettings);

        // create a listener for output
<span class="fc" id="L541">        final AuditListener listener = createListener(cliOptions.format, cliOptions.outputLocation);</span>

        // create RootModule object and run it
        final int errorCounter;
<span class="fc" id="L545">        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();</span>
<span class="fc" id="L546">        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);</span>

        try {
<span class="fc" id="L549">            rootModule.setModuleClassLoader(moduleClassLoader);</span>
<span class="fc" id="L550">            rootModule.configure(config);</span>
<span class="fc" id="L551">            rootModule.addListener(listener);</span>

            // run RootModule
<span class="fc" id="L554">            errorCounter = rootModule.process(cliOptions.files);</span>
        }
        finally {
<span class="fc" id="L557">            rootModule.destroy();</span>
        }

<span class="fc" id="L560">        return errorCounter;</span>
    }

    /**
     * Creates a new instance of the root module that will control and run
     * Checkstyle.
     * @param name The name of the module. This will either be a short name that
     *        will have to be found or the complete package name.
     * @param moduleClassLoader Class loader used to load the root module.
     * @return The new instance of the root module.
     * @throws CheckstyleException if no module can be instantiated from name
     */
    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)
            throws CheckstyleException {
<span class="fc" id="L574">        final ModuleFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L575">                Checker.class.getPackage().getName(), moduleClassLoader);</span>

<span class="fc" id="L577">        return (RootModule) factory.createModule(name);</span>
    }

    /**
     * Loads properties from a File.
     * @param file
     *        the properties file
     * @return the properties in file
     * @throws CheckstyleException
     *         when could not load properties file
     */
    private static Properties loadProperties(File file)
            throws CheckstyleException {
<span class="fc" id="L590">        final Properties properties = new Properties();</span>

<span class="fc" id="L592">        try (InputStream stream = Files.newInputStream(file.toPath())) {</span>
<span class="fc" id="L593">            properties.load(stream);</span>
        }
<span class="fc" id="L595">        catch (final IOException ex) {</span>
<span class="fc" id="L596">            final LocalizedMessage loadPropertiesExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,
<span class="fc" id="L598">                    new String[] {file.getAbsolutePath()}, null, Main.class, null);</span>
<span class="fc" id="L599">            throw new CheckstyleException(loadPropertiesExceptionMessage.getMessage(), ex);</span>
<span class="fc" id="L600">        }</span>

<span class="fc" id="L602">        return properties;</span>
    }

    /**
     * This method creates in AuditListener an open stream for validation data, it must be closed by
     * {@link RootModule} (default implementation is {@link Checker}) by calling
     * {@link AuditListener#auditFinished(AuditEvent)}.
     * @param format format of the audit listener
     * @param outputLocation the location of output
     * @return a fresh new {@code AuditListener}
     * @exception IOException when provided output location is not found
     */
    private static AuditListener createListener(String format, String outputLocation)
            throws IOException {
        final AuditListener listener;
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L618">            final OutputStream out = getOutputStream(outputLocation);</span>
<span class="fc" id="L619">            final AutomaticBean.OutputStreamOptions closeOutputStreamOption =</span>
<span class="fc" id="L620">                    getOutputStreamOptions(outputLocation);</span>
<span class="fc" id="L621">            listener = new XMLLogger(out, closeOutputStreamOption);</span>
<span class="fc" id="L622">        }</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        else if (PLAIN_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L624">            final OutputStream out = getOutputStream(outputLocation);</span>
<span class="fc" id="L625">            final AutomaticBean.OutputStreamOptions closeOutputStreamOption =</span>
<span class="fc" id="L626">                    getOutputStreamOptions(outputLocation);</span>
<span class="fc" id="L627">            listener = new DefaultLogger(out, closeOutputStreamOption);</span>
<span class="fc" id="L628">        }</span>
        else {
<span class="fc" id="L630">            final LocalizedMessage outputFormatExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, CREATE_LISTENER_EXCEPTION,
                    new String[] {format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME}, null,
                    Main.class, null);
<span class="fc" id="L634">            throw new IllegalStateException(outputFormatExceptionMessage.getMessage());</span>
        }

<span class="fc" id="L637">        return listener;</span>
    }

    /**
     * Create output stream or return System.out
     * @param outputLocation output location
     * @return output stream
     * @throws IOException might happen
     */
    @SuppressWarnings(&quot;resource&quot;)
    private static OutputStream getOutputStream(String outputLocation) throws IOException {
        final OutputStream result;
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if (outputLocation == null) {</span>
<span class="fc" id="L650">            result = System.out;</span>
        }
        else {
<span class="fc" id="L653">            result = Files.newOutputStream(Paths.get(outputLocation));</span>
        }
<span class="fc" id="L655">        return result;</span>
    }

    /**
     * Create {@link AutomaticBean.OutputStreamOptions} for the given location.
     * @param outputLocation output location
     * @return output stream options
     */
    private static AutomaticBean.OutputStreamOptions getOutputStreamOptions(String outputLocation) {
        final AutomaticBean.OutputStreamOptions result;
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (outputLocation == null) {</span>
<span class="fc" id="L666">            result = AutomaticBean.OutputStreamOptions.NONE;</span>
        }
        else {
<span class="fc" id="L669">            result = AutomaticBean.OutputStreamOptions.CLOSE;</span>
        }
<span class="fc" id="L671">        return result;</span>
    }

    /**
     * Determines the files to process.
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @param filesToProcess
     *        arguments that were not processed yet but shall be
     * @return list of files to process
     */
    private static List&lt;File&gt; getFilesToProcess(List&lt;Pattern&gt; patternsToExclude,
            String... filesToProcess) {
<span class="fc" id="L683">        final List&lt;File&gt; files = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (String element : filesToProcess) {</span>
<span class="fc" id="L685">            files.addAll(listFiles(new File(element), patternsToExclude));</span>
        }

<span class="fc" id="L688">        return files;</span>
    }

    /**
     * Traverses a specified node looking for files to check. Found files are added to a specified
     * list. Subdirectories are also traversed.
     * @param node
     *        the node to process
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return found files
     */
    private static List&lt;File&gt; listFiles(File node, List&lt;Pattern&gt; patternsToExclude) {
        // could be replaced with org.apache.commons.io.FileUtils.list() method
        // if only we add commons-io library
<span class="fc" id="L702">        final List&lt;File&gt; result = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (node.canRead()) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">            if (node.isDirectory()) {</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">                if (!isDirectoryExcluded(node.getAbsolutePath(), patternsToExclude)) {</span>
<span class="fc" id="L707">                    final File[] files = node.listFiles();</span>
                    // listFiles() can return null, so we need to check it
<span class="fc bfc" id="L709" title="All 2 branches covered.">                    if (files != null) {</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">                        for (File element : files) {</span>
<span class="fc" id="L711">                            result.addAll(listFiles(element, patternsToExclude));</span>
                        }
                    }
<span class="fc" id="L714">                }</span>
            }
<span class="fc bfc" id="L716" title="All 2 branches covered.">            else if (node.isFile()) {</span>
<span class="fc" id="L717">                result.add(node);</span>
            }
        }
<span class="fc" id="L720">        return result;</span>
    }

    /**
     * Checks if a directory {@code path} should be excluded based on if it matches one of the
     * patterns supplied.
     * @param path The path of the directory to check
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return True if the directory matches one of the patterns.
     */
    private static boolean isDirectoryExcluded(String path, List&lt;Pattern&gt; patternsToExclude) {
<span class="fc" id="L731">        boolean result = false;</span>

<span class="fc bfc" id="L733" title="All 2 branches covered.">        for (Pattern pattern : patternsToExclude) {</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (pattern.matcher(path).find()) {</span>
<span class="fc" id="L735">                result = true;</span>
<span class="fc" id="L736">                break;</span>
            }
<span class="fc" id="L738">        }</span>

<span class="fc" id="L740">        return result;</span>
    }

    /** Prints the usage information. **/
    private static void printUsage() {
<span class="fc" id="L745">        final HelpFormatter formatter = new HelpFormatter();</span>
<span class="fc" id="L746">        formatter.setWidth(HELP_WIDTH);</span>
<span class="fc" id="L747">        formatter.printHelp(String.format(&quot;java %s [options] -c &lt;config.xml&gt; file...&quot;,</span>
<span class="fc" id="L748">                Main.class.getName()), buildOptions());</span>
<span class="fc" id="L749">    }</span>

    /**
     * Builds and returns list of parameters supported by cli Checkstyle.
     * @return available options
     */
    private static Options buildOptions() {
<span class="fc" id="L756">        final Options options = new Options();</span>
<span class="fc" id="L757">        options.addOption(OPTION_C_NAME, true, &quot;Sets the check configuration file to use.&quot;);</span>
<span class="fc" id="L758">        options.addOption(OPTION_O_NAME, true, &quot;Sets the output file. Defaults to stdout&quot;);</span>
<span class="fc" id="L759">        options.addOption(OPTION_P_NAME, true, &quot;Loads the properties file&quot;);</span>
<span class="fc" id="L760">        options.addOption(OPTION_S_NAME, true,</span>
                &quot;Print xpath suppressions at the file's line and column position. &quot;
                        + &quot;Argument is the line and column number (separated by a : ) in the file &quot;
                        + &quot;that the suppression should be generated for&quot;);
<span class="fc" id="L764">        options.addOption(OPTION_TAB_WIDTH_NAME, true,</span>
<span class="fc" id="L765">                String.format(&quot;Sets the length of the tab character. Used only with \&quot;-s\&quot; option. &quot;</span>
                        + &quot;Default value is %s&quot;,
                        DEFAULT_TAB_WIDTH));
<span class="fc" id="L768">        options.addOption(OPTION_F_NAME, true, String.format(</span>
                &quot;Sets the output format. (%s|%s). Defaults to %s&quot;,
                PLAIN_FORMAT_NAME, XML_FORMAT_NAME, PLAIN_FORMAT_NAME));
<span class="fc" id="L771">        options.addOption(OPTION_V_NAME, false, &quot;Print product version and exit&quot;);</span>
<span class="fc" id="L772">        options.addOption(OPTION_T_NAME, OPTION_TREE_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file&quot;);
<span class="fc" id="L774">        options.addOption(OPTION_CAPITAL_T_NAME, OPTION_TREE_COMMENT_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file including comments&quot;);
<span class="fc" id="L776">        options.addOption(OPTION_J_NAME, OPTION_JAVADOC_TREE_NAME, false,</span>
                &quot;Print Parse tree of the Javadoc comment&quot;);
<span class="fc" id="L778">        options.addOption(OPTION_CAPITAL_J_NAME, OPTION_TREE_JAVADOC_NAME, false,</span>
                &quot;Print full Abstract Syntax Tree of the file&quot;);
<span class="fc" id="L780">        options.addOption(OPTION_D_NAME, OPTION_DEBUG_NAME, false,</span>
                &quot;Print all debug logging of CheckStyle utility&quot;);
<span class="fc" id="L782">        options.addOption(OPTION_E_NAME, OPTION_EXCLUDE_NAME, true,</span>
                &quot;Directory path to exclude from CheckStyle&quot;);
<span class="fc" id="L784">        options.addOption(OPTION_X_NAME, OPTION_EXCLUDE_REGEXP_NAME, true,</span>
                &quot;Regular expression of directory to exclude from CheckStyle&quot;);
<span class="fc" id="L786">        options.addOption(OPTION_EXECUTE_IGNORED_MODULES_NAME, false,</span>
                &quot;Allows ignored modules to be run.&quot;);
<span class="fc" id="L788">        options.addOption(OPTION_CAPITAL_C_NAME, OPTION_CHECKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of Checker threads (must be greater than zero)&quot;);
<span class="fc" id="L790">        options.addOption(OPTION_CAPITAL_W_NAME, OPTION_TREE_WALKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of TreeWalker threads (must be greater than zero)&quot;);
<span class="fc" id="L792">        return options;</span>
    }

    /** Helper structure to clear show what is required for Checker to run. **/
    private static class CliOptions {

        /** Properties file location. */
        private String propertiesLocation;
        /** Config file location. */
        private String configLocation;
        /** Output format. */
        private String format;
        /** Output file location. */
        private String outputLocation;
        /** List of file to validate. */
        private List&lt;File&gt; files;
        /** Switch whether to execute ignored modules or not. */
        private boolean executeIgnoredModules;
        /** The checker threads number. */
        private int checkerThreadsNumber;
        /** The tree walker threads number. */
        private int treeWalkerThreadsNumber;
        /** LineNo and columnNo for the suppression. */
        private String suppressionLineColumnNumber;
        /** Tab character length. */
        private int tabWidth;

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>